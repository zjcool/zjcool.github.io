<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eden&#39;s Blog</title>
  
  <subtitle>Peace &amp;&amp; Love</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-10T09:43:21.213Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Eden</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kubernetes学习笔记-17</title>
    <link href="http://yoursite.com/2018/12/10/kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-17/"/>
    <id>http://yoursite.com/2018/12/10/kubernetes学习笔记-17/</id>
    <published>2018-12-10T06:21:45.000Z</published>
    <updated>2018-12-10T09:43:21.213Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">  <p>今天一天过得不错吧？梦想是不是更远了？ </p></blockquote><blockquote>  <p>今天想跟大家分享的K8s中基于Deployment的实现水平扩展/收缩以及滚动更新。</p></blockquote><h4 id="水平扩展-收缩"><a href="#水平扩展-收缩" class="headerlink" title="水平扩展/收缩"></a>水平扩展/收缩</h4><p><strong>水平扩展是只要增加服务器数量，就能线性扩充系统性能。</strong>在K8s中，<code>Deployment</code>是<strong>控制器模式</strong>的一个完整实现，其实现了一个重要的功能：<strong>水平扩展/收缩</strong>（horizontal scaling out/in）。</p><p>同时，k8s中，实现滚动更新的API对象称作：ReplicaSet。它的定义是Deployment的一个子集，<strong>更重要的是，Deployment控制器实际操纵的，是ReplicaSet对象，而不是Pod对象</strong>。同时我们需要明白，一个Deployment所管理的Pod，它的ownerReference是ReplicaSet。</p><p>下面我们来看一个Deployment：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>      </td>      <td class="code">        <pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-deployment</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.7.9</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br></pre>      </td>    </tr>  </table></figure><p>可以看出，这里启动是3个版本为1.7.9的Nginx服务，那么在具体实现上，这个Deployment与ReplicaSet，以及Pod的关系如下图所示：<br><img src="/images/1.png" alt=""><br>通过这张图，我们可以很清楚的看到，一个replicas=3的Deployment与它的ReplicaSet以及Pod的关系，实际上是一种<strong>层层控制</strong>的关系。</p><p>其中ReplicaSet负责通过“控制器模式”，保证系统中Pod的个数永远等于设置个数。这也正是Deployment只允许容器的restartPolicy=Always的主要原因：只有在容器能保证是 Running 状态的前提下，ReplicaSet调整Pod的个数才有意义。</p><p>所以只要将replicas值改动就可以实现水平扩展/收缩</p><h4 id="滚动更新"><a href="#滚动更新" class="headerlink" title="滚动更新"></a>滚动更新</h4><p>还是以上面的那个Deployment为例:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">kubectl create -f nginx-deployment.yaml --record</span><br></pre>      </td>    </tr>  </table></figure><p><code>--reord</code> 是记录下你每次操作所执行的命令，以方便后面查看。同时，你可以通过 <code>kubectl edit</code> 修改etcd里的api对象（它是把API对象的内容下载到本地文件，修改完后，可以提交上去），<code>kubectl edit</code> 修改完成后，Kubernetes 就会立即触发 <strong>滚动更新</strong>。</p><p>滚动更新过程：首先会根据新的Pod的定义，创建一个新的ReplicaSet，这个新的 ReplicaSet 的初始 Pod 数为0，然后 Deployment Controller 开始将这个新的 ReplicaSet 控制的新的 Pod 数加1，将旧的 Pod 数减1，如此交替进行。<br>像这样，将一个集群中正在运行的多个Pod版本，交替地逐一升级的过程，就是<strong>滚动更新</strong>。</p><p>举个例子来说明<strong>滚动更新的好处</strong>：在刚升级的时候，集群中只有1个新版本的Pod，如果新版本的Pod有问题，无法启动，那么滚动更新就会停止，而在这个过程中旧Pod依然存在，服务不会受到影响。（当然这里要求你会使用Pod的Health Check机制来检查应用的运行状态，而不是简单的依赖容器的running状态）。</p><p>为了进一步保证服务的连续性，Deployment Controller还会确保，在任何时间窗口，只有一定比例的Pod处于离线状态，一定比例的新Pod被创建出来。这个比例是可以配的，默认是DESIRED的值 25%。这个策略是Deployment对象的一个字段，名为 <strong>RollingUpdateStrategy</strong> 。</p><p>综上，我们可以扩展一下Depolyment，ReplicaSet和Pod的关系图了。<br><img src="/images/2.png" alt=""><br>如上所示：Deployment的控制器，实际上控制的是ReplicaSet的数目，以及每个ReplicaSet的属性。</p><p>而一个应用的版本，对应的正是一个ReplicaSet，这个版本应用的Pod数量，则由ReplicaSet通过它自己的控制器（ReplicaSet Controller）来保证。</p><h4 id="版本控制基本原理"><a href="#版本控制基本原理" class="headerlink" title="版本控制基本原理"></a>版本控制基本原理</h4><p>在升级镜像版本时，如果Pod拉取不到有效的镜像，升级就会失败，可以使用 <code>kubectl rollout undo</code> 命令，将整个Deployment回滚到上一个版本。<br><code>kubectl rollout history</code> 命令可以用来查看每次Deployment变更对应的版本</p><p>参考资料：<a href="https://time.geekbang.org/column/article/40906" target="_blank" rel="noopener">https://time.geekbang.org/column/article/40906</a></p><p>以上就是今天的全部分享。。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote class=&quot;blockquote-center&quot;&gt;
  &lt;p&gt;今天一天过得不错吧？梦想是不是更远了？ &lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
  &lt;p&gt;今天想跟大家分享的K8s中基于Deployment的实现水平扩展/收缩以及滚动
      
    
    </summary>
    
      <category term="Kubernetes" scheme="http://yoursite.com/categories/Kubernetes/"/>
    
      <category term="技术学习" scheme="http://yoursite.com/categories/Kubernetes/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="K8s" scheme="http://yoursite.com/tags/K8s/"/>
    
      <category term="Deployment" scheme="http://yoursite.com/tags/Deployment/"/>
    
  </entry>
  
  <entry>
    <title>prometheus学习</title>
    <link href="http://yoursite.com/2018/12/07/prometheus%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/12/07/prometheus学习/</id>
    <published>2018-12-07T11:32:14.000Z</published>
    <updated>2018-12-08T11:43:49.862Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">  <p>人的一切痛苦，本质上都是对自己无能的愤怒。 </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote class=&quot;blockquote-center&quot;&gt;
  &lt;p&gt;人的一切痛苦，本质上都是对自己无能的愤怒。 &lt;/p&gt;
&lt;/blockquote&gt;
      
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="prometheus" scheme="http://yoursite.com/tags/prometheus/"/>
    
  </entry>
  
</feed>
