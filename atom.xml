<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>回归初心，轻装前行</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zjcool.github.io/"/>
  <updated>2019-12-19T07:09:24.368Z</updated>
  <id>https://zjcool.github.io/</id>
  
  <author>
    <name>zhangj</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【明明白白系列之 ArrayList（2）】-- 增、删、改、查</title>
    <link href="https://zjcool.github.io/2019/12/19/%E3%80%90%E6%98%8E%E6%98%8E%E7%99%BD%E7%99%BD%E7%B3%BB%E5%88%97%E4%B9%8B-ArrayList%EF%BC%882%EF%BC%89%E3%80%91/"/>
    <id>https://zjcool.github.io/2019/12/19/【明明白白系列之-ArrayList（2）】/</id>
    <published>2019-12-19T03:17:00.000Z</published>
    <updated>2019-12-19T07:09:24.368Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 19 2019 15:09:44 GMT+0800 (中国标准时间) --><hr><h1 id="【明明白白系列之-ArrayList（2）】–-增、删、改、查"><a href="#【明明白白系列之-ArrayList（2）】–-增、删、改、查" class="headerlink" title="【明明白白系列之 ArrayList（2）】– 增、删、改、查"></a>【明明白白系列之 ArrayList（2）】– 增、删、改、查</h1><hr><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>只要是开发的过的同学，增删改查想必是十分熟悉的。那么今天给大家分享是 ArrayList 里的增删改查，当然这里所谓的“增删改查”是我个人对其的理解。这样的归类是否合理，仁者见仁 。ok，开始吧！</p><hr><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><p>首先介绍的是增，ArrayList提供的**增**的方法有4个。分别是在尾部增加单个元素、在特定位置增加单个元素、在尾部增加一个集合、在特定位置开始增加一个集合。</p>详细代码如下:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在尾部添加值 </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//自动扩容</span></span><br><span class="line">       ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">       elementData[size++] = e;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 指定位置添加值, 当前值以及之后的值 往后挪一位</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//范围检查</span></span><br><span class="line">       rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">       ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">       <span class="comment">//当前值和之后的值 往后挪一位</span></span><br><span class="line">       System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                        size - index);</span><br><span class="line">       </span><br><span class="line">       elementData[index] = element;</span><br><span class="line">       size++;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//在集合尾部添加集合</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">       Object[] a = c.toArray();</span><br><span class="line">       <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">       ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">       System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">       size += numNew;</span><br><span class="line">       <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 在特定位置添加集合</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">       rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">       Object[] a = c.toArray();</span><br><span class="line">       <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">       ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> numMoved = size - index;</span><br><span class="line">       <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">           System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                            numMoved);</span><br><span class="line"></span><br><span class="line">       System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">       size += numNew;</span><br><span class="line">       <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>平时我们常用的是 add（Obj）或者 add(Collection)，很少会在特定位置 add 。这里需要提醒的是，那么在特定位置add的时候，之前在该位置的数据和后面的数据会依次往后挪。</p><hr><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><p>ArrayList提供了很多 删除方法实现，来针对不同场景。详细请看代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 删除索引对应的值，返回移除的值，所有索引后的值，向前移动一位</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       rangeCheck(index);</span><br><span class="line"></span><br><span class="line">       modCount++;</span><br><span class="line">       E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">           System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                            numMoved);</span><br><span class="line">       elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> oldValue;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//删除值，如果存在，移除第一个，返回true，如果不存在，返回false</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">               <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   fastRemove(index);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">               <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                   fastRemove(index);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 删除索引对应的值 只是不返回删除的值</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">           System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                            numMoved);</span><br><span class="line">       elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 清空集合</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="comment">// clear to let GC do its work</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">           elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       size = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//删除集合一个索引范围的值</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="keyword">int</span> numMoved = size - toIndex;</span><br><span class="line">       <span class="comment">//将 toIndex 之后的值 依次从 fromIndex位置开始复制</span></span><br><span class="line">       System.arraycopy(elementData, toIndex, elementData, fromIndex,numMoved);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// clear to let GC do its work</span></span><br><span class="line">       <span class="keyword">int</span> newSize = size - (toIndex-fromIndex);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = newSize; i &lt; size; i++) &#123;</span><br><span class="line">           elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       size = newSize;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">//删除集合中 包括c集合中的内容 A-B</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">       Objects.requireNonNull(c);</span><br><span class="line">       <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//删除不在c中的其他元素，即请求交集</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">       Objects.requireNonNull(c);</span><br><span class="line">       <span class="keyword">return</span> batchRemove(c, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//批量删除具体实现</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;</span><br><span class="line">       <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">               <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">                   elementData[w++] = elementData[r];</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">// Preserve behavioral compatibility with AbstractCollection,</span></span><br><span class="line">           <span class="comment">// even if c.contains() throws.</span></span><br><span class="line">           <span class="keyword">if</span> (r != size) &#123;</span><br><span class="line">               System.arraycopy(elementData, r,</span><br><span class="line">                                elementData, w,</span><br><span class="line">                                size - r);</span><br><span class="line">               w += size - r;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">               <span class="comment">// clear to let GC do its work</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</span><br><span class="line">                   elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">               modCount += size - w;</span><br><span class="line">               size = w;</span><br><span class="line">               modified = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> modified;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据过滤条件删除，满足条件的删除</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeIf</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> E&gt; filter)</span> </span>&#123;</span><br><span class="line">       Objects.requireNonNull(filter);</span><br><span class="line">       <span class="comment">// figure out which elements are to be removed</span></span><br><span class="line">       <span class="comment">// any exception thrown from the filter predicate at this stage</span></span><br><span class="line">       <span class="comment">// will leave the collection unmodified</span></span><br><span class="line">       <span class="keyword">int</span> removeCount = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">final</span> BitSet removeSet = <span class="keyword">new</span> BitSet(size);</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">           <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">           <span class="keyword">final</span> E element = (E) elementData[i];</span><br><span class="line">           <span class="keyword">if</span> (filter.test(element)) &#123;</span><br><span class="line">               removeSet.set(i);</span><br><span class="line">               removeCount++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// shift surviving elements left over the spaces left by removed elements</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> anyToRemove = removeCount &gt; <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (anyToRemove) &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> newSize = size - removeCount;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) &#123;</span><br><span class="line">               i = removeSet.nextClearBit(i);</span><br><span class="line">               elementData[j] = elementData[i];</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> k=newSize; k &lt; size; k++) &#123;</span><br><span class="line">               elementData[k] = <span class="keyword">null</span>;  <span class="comment">// Let gc do its work</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">this</span>.size = newSize;</span><br><span class="line">           <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">           &#125;</span><br><span class="line">           modCount++;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> anyToRemove;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>看完增和删的代码，细心的你们，想必也发现了有一行语句会经常出现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modCount++;</span><br></pre></td></tr></table></figure><p>看着好像也没什么作用，ArrayList 好像也没有定义这个字段。那么先简单剧透一下，这个字段是来着父类AbstractList，目的是为了实现<strong>fail-fast机制</strong>。这个机制后面会详细的介绍。这里留个思考题，为什么只有增和删会用到这个<strong>fail-fast机制</strong>呢？</p><hr><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><p>ArrayList 里的<strong>改</strong>方法不多，代码也十分简单，详细的说明已经在代理里注释了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//设置值 返回旧值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对集合中的元素进行 统一操作，简单的如：加减乘除等等</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(operator);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">            elementData[i] = operator.apply((E) elementData[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><p>最后，没错就是最后一个“查”了。老规矩还是很简单（其实是我不知道该说什么，哈哈哈），看代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">// 判断集合是否包含o</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 返回 集合中第一个o的数组位置,如果没有，返回-1</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">               <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                   <span class="keyword">return</span> i;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">               <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                   <span class="keyword">return</span> i;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 返回 集合中最后一个o的数组位置,如果没有，返回-1</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">               <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                   <span class="keyword">return</span> i;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">               <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                   <span class="keyword">return</span> i;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//返回索引对应的存储值</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       rangeCheck(index);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> elementData(index);</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">//查询是否为空集合</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//查询集合大小</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> size;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>ok！增删改查的分享到此结束，但是增删改查的路才刚刚开始。。。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Dec 19 2019 15:09:44 GMT+0800 (中国标准时间) --&gt;&lt;hr&gt;&lt;h1 id=&quot;【明明白白系列之-ArrayList（2）】–-增、删、改、查&quot;&gt;&lt;a href=&quot;#【明明白白系列之-ArrayList（2）】–
      
    
    </summary>
    
    
      <category term="明明白白系列" scheme="https://zjcool.github.io/categories/%E6%98%8E%E6%98%8E%E7%99%BD%E7%99%BD%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="jdk源码" scheme="https://zjcool.github.io/tags/jdk%E6%BA%90%E7%A0%81/"/>
    
      <category term="数据结构" scheme="https://zjcool.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【明明白白系列之 ArrayList（1）】-- 字段、构造方法、以及自动扩容</title>
    <link href="https://zjcool.github.io/2019/12/18/%E3%80%90jdk%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%91-ArrayList/"/>
    <id>https://zjcool.github.io/2019/12/18/【jdk源码解析】-ArrayList/</id>
    <published>2019-12-17T20:20:00.000Z</published>
    <updated>2019-12-18T16:50:33.192Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 19 2019 15:09:44 GMT+0800 (中国标准时间) --><hr><h1 id="【明明白白系列之-ArrayList（1）】–-字段、构造方法、以及自动扩容"><a href="#【明明白白系列之-ArrayList（1）】–-字段、构造方法、以及自动扩容" class="headerlink" title="【明明白白系列之 ArrayList（1）】– 字段、构造方法、以及自动扩容"></a>【明明白白系列之 ArrayList（1）】– 字段、构造方法、以及自动扩容</h1><hr><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>平时工作，我们经常会用到ArrayList，但是却从没有好好研究过底层，最近正好有些许闲暇时间，就稍微探究下，那就分享一下自己研读 ArrayList 源码的记录（基于jdk8），如果有什么理解不对的地方，欢迎指正。好了，废话就不多说，直接开始。<br><br>ArrayList类的所有内容，总结下可分为以下几个部分：构造方法、增、删、改、查、排序、自动扩容、遍历、子集合、序列化。那么接下来，我将一一介绍各个部分，希望能给大家些许帮助，同时也借此机会加深自己对ArrayList的理解。<br><br></p><hr><h2 id="类字段和实例字段"><a href="#类字段和实例字段" class="headerlink" title="类字段和实例字段"></a>类字段和实例字段</h2><p>首先，我们先来看看ArrayList类属性和实例属性，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认长度10</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当初始化大小为0 数组的实现 ---  new ArrayList(0) 或者 new ArrayList(collection)且collection.size=0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不指定初始化的的实现  ---- new ArrayList() </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际存储数据的。当添加第一个数据，会直接将容量大小转为 DEFAULT_CAPACITY（不会被序列化）</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//已存在集合中的数据大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 最大的集合大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p>属性不多，也很好理解， <strong>EMPTY_ELEMENTDATA</strong> 是构造方法传入<strong>0</strong>的时候的实现，<strong>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</strong> 是构造方法不传时的实现。其实没有什么大的区别。<br><br>唯一需要注意的是<strong>DEFAULT_CAPACITY</strong>虽然说是默认容量为10，但是实际初始化<strong>new ArrayList()</strong> 或者 <strong>new ArrayList(0)</strong> 产生新的实例时，实际的数组长度还是<strong>0</strong>的。之后介绍的构造方法，我们可以很清楚的认识这一点。 但是在此基础上，一旦添加一个元素，数组容量会总动扩容到<strong>10</strong>，这里只点一下，后面会详细解释。</p><hr><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>ArrayList提供了三个构造方法，详细代码如下。仔细研读下具体实现，就能发现上面我所说的为什么<strong>new ArrayList(0)</strong>或者<strong>new ArrayList()</strong> 产生的实例的<strong>数组长度是0</strong>，而不是默认的<strong>10</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带初始大小的构造方法</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+ initialCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 空构造方法</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 传入Collection的构造方法</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">     elementData = c.toArray();</span><br><span class="line">     <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">         <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">             elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// replace with empty array.</span></span><br><span class="line">         <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="自动扩容机制"><a href="#自动扩容机制" class="headerlink" title="自动扩容机制"></a>自动扩容机制</h2><p>大家都知道 ArrayList 提供了一个默认的容量10，那么有没有想过一个问题，如果我的集合大小超过了10，ArrayList会怎么处理呢？我们好像从来没有主动为ArrayList扩大容量，ArrayList好像自动帮我们做了扩容处理。确实是这样的，接下来我要介绍下的就是 <strong>ArrayList 自动扩容机制。</strong><br><br><br>依然是通过自动扩容的代码来介绍，代码相对比较简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//开始自动扩容</span></span><br><span class="line">   <span class="comment">//例如添加元素时，会先确保ArrayList能容乃所有元素，会将（size+addsize） 作为 minCapacity 传入</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">      ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//计算容量(最小为10)</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">          <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> minCapacity;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//确保集合 能达到指定大小的存储能力（最低是10） </span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//遍历的时候，不能扩容，即不能往集合中添加元素</span></span><br><span class="line">      modCount++;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// overflow-conscious code</span></span><br><span class="line">      <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">          grow(minCapacity);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动扩容核心--具体实现</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// overflow-conscious code</span></span><br><span class="line">      <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">      <span class="comment">//扩容一次 1.5倍</span></span><br><span class="line">      <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 如果还是小于 minCapacity，直接改为传进来的值</span></span><br><span class="line">      <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">          newCapacity = minCapacity;</span><br><span class="line">      <span class="comment">// 如果大于最大的 MAX_ARRAY_SIZE ，构建一个大容量   </span></span><br><span class="line">      <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">          newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">      <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">      elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//返回一个超大容量 （ 在size 等于 Integer，MAX_VALUE抛出 java.lang.OutOfMemoryError: Requested array size exceeds VM limit）</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">      <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">          Integer.MAX_VALUE :</span><br><span class="line">          MAX_ARRAY_SIZE;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>通过阅读 grow（）方法，总结一下，自动扩容的逻辑是：如果当前需要存储的 minCapacity 大于element.length, 那么就扩大<strong>1.5</strong>倍，如果还是不够存，那么直接将 newCapacity 容量设置为 minCapacity。如果 newCapacity 大于 MAX_ARRAY_SIZE ，返回一个超大容量，当然最大不能超过 Integer.MAX_VALUE。</p><p>最后，ArrayList 还提供了一个手动扩容的 public 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 确保 指定大小的存储能力的集合  -- 最小大小10,</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">           <span class="comment">// any size if not default element table</span></span><br><span class="line">           ? <span class="number">0</span></span><br><span class="line">           <span class="comment">// larger than default for default empty table. It's already</span></span><br><span class="line">           <span class="comment">// supposed to be at default size.</span></span><br><span class="line">           : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">           ensureExplicitCapacity(minCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>好的，今天的分享就到此为止。就是这么突然，是不是有点意犹未尽的赶脚。。。不用着急，接下来几天，会进行ArrayList的后续解读。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Dec 19 2019 15:09:44 GMT+0800 (中国标准时间) --&gt;&lt;hr&gt;&lt;h1 id=&quot;【明明白白系列之-ArrayList（1）】–-字段、构造方法、以及自动扩容&quot;&gt;&lt;a href=&quot;#【明明白白系列之-ArrayLi
      
    
    </summary>
    
    
      <category term="明明白白系列" scheme="https://zjcool.github.io/categories/%E6%98%8E%E6%98%8E%E7%99%BD%E7%99%BD%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="jdk源码" scheme="https://zjcool.github.io/tags/jdk%E6%BA%90%E7%A0%81/"/>
    
      <category term="数据结构" scheme="https://zjcool.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【springboot源码解析】-- 启动过程</title>
    <link href="https://zjcool.github.io/2019/11/19/%E3%80%90springboot%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%91-SpringApplication/"/>
    <id>https://zjcool.github.io/2019/11/19/【springboot源码解析】-SpringApplication/</id>
    <published>2019-11-19T08:05:00.000Z</published>
    <updated>2019-12-19T07:07:54.889Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 19 2019 15:09:44 GMT+0800 (中国标准时间) --><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>从工作开始接触 springboot 到现在将近过去两年时光了，虽偶然看看springboot启动源码，但从未仔细研读深究过，网上虽然有很多源码解析，但是每次读几篇就会因为各种原因半途而止，这次准备花一点时间好好将底层源码研究一番。<br><br>好了，我们正式开始 springboot 之旅吧!请看下面代码吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想必大家对上面的代码都不会陌生，任何一个 springboot 服务都是由此方法开始启动的，开始一个个来解释。</p><h3 id="SpringBootApplication-注解"><a href="#SpringBootApplication-注解" class="headerlink" title="@SpringBootApplication 注解"></a>@SpringBootApplication 注解</h3><p>官方给出的解释是</p><blockquote><p>This is a convenience annotation that is equivalent to declaring {@code @Configuration}, {@code @EnableAutoConfiguration} and {@code @ComponentScan}.</p></blockquote><p>也就是说 <strong>@SpringBootApplication</strong> 是 <strong>@Configuration</strong>、<strong>@EnableAutoConfiguration</strong>、<strong>@ComponentScan</strong> 三个注解的组合注解。</p><p>想详细了解这三个注解的含义，可以阅读以下文章：</p><ul><li><a href="https://www.jianshu.com/p/721c76c1529c" title="深入理解 -- @Configuration 注解" target="_blank" rel="noopener">深入理解 – @Configuration 注解</a></li><li><a href="https://blog.csdn.net/qq_40915748/article/details/85254369" title="深入理解 -- @EnableAutoConfiguration 注解" target="_blank" rel="noopener">深入理解 – @EnableAutoConfiguration 注解</a></li><li><a href="https://www.jianshu.com/p/64aac6461d5b" title="深入理解 -- @ComponentScan 注解" target="_blank" rel="noopener">深入理解 – @ComponentScan 注解</a></li></ul><h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><p>主函数依次执行<br>step 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpringApplication.run(Application.class, args);</span><br></pre></td></tr></table></figure><p>step 2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt;[] primarySources,</span></span></span><br><span class="line"><span class="function"><span class="params">String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> SpringApplication(primarySources).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>primarySources</strong> 就是 <strong>Application.class</strong></p><p>step 3：<br>开始执行的 <strong>SpringApplication</strong> 的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">Assert.notNull(primarySources, <span class="string">"PrimarySources must not be null"</span>);</span><br><span class="line"><span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">        <span class="comment">//&lt;1&gt; 从classPath中推测当前应用是什么类型的应用，</span></span><br><span class="line"><span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">        <span class="comment">//&lt;2&gt; 设置 spring 容器的初始化器（ApplicationContextInitializer）</span></span><br><span class="line">setInitializers((Collection) getSpringFactoriesInstances(</span><br><span class="line">ApplicationContextInitializer.class));</span><br><span class="line">        <span class="comment">// &lt;3&gt;设置 spring 容器的监听器</span></span><br><span class="line">setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">        <span class="comment">// 设置主类，即 Application.class</span></span><br><span class="line"><span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&lt;1&gt; <code>WebApplicationType</code>类型包括 <code>SERVLET</code>、<code>REACTIVE</code>、<code>NONE</code>，后面会根据不同的类型，以不同的方式来启动服务<br>&lt;2&gt;会从 spring-boot 和 spring-boot-autoconfigure 的jar包里的<code>META-INF/spring.factories</code> 中加载所有的 <code>ApplicationContextInitializer</code> 作为 spring 容器的初始化器 ApplicationContextInitializer<br>&lt;3&gt; 会从 spring-boot 和spring-boot-autoconfigure 的jar包里的<code>META-INF/spring.factorie</code>s 中加载所有的 <code>Listener</code></p><p>step 4： 开始运行Spring 应用，刷新上下文</p><p>这一步内容有点多，请耐心查看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SpringApptionlication.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// springboot 启动过程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// stopWatch 是一个计算代码时间的类</span></span><br><span class="line">StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">stopWatch.start();</span><br><span class="line">ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//异常收集容器</span></span><br><span class="line">Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 开启无设备鼠标键盘模式（需要提供一些（设备）信息给客户端）</span></span><br><span class="line">configureHeadlessProperty();</span><br><span class="line"><span class="comment">// 反射生成 SpringApplicationRunListener 的实现类----&gt; EventPublishingRunListener 即获取Spring启动监听器 </span></span><br><span class="line">SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line"><span class="comment">// 触发 ApplicationStartingEvent 事件，执行对应动作</span></span><br><span class="line">listeners.starting();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 获取环境配置</span></span><br><span class="line">ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</span><br><span class="line">args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;1&gt;生成环境配置+设置环境变量</span></span><br><span class="line">ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">applicationArguments);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 忽略的配置的 bean</span></span><br><span class="line">configureIgnoreBeanInfo(environment);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出banner</span></span><br><span class="line">Banner printedBanner = printBanner(environment);</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成应用上下文（这里会生成基于注解的 AnnotationConfigServletWebServerApplicationContext）</span></span><br><span class="line">context = createApplicationContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反射生产一些异常收集器</span></span><br><span class="line">exceptionReporters = getSpringFactoriesInstances(</span><br><span class="line">SpringBootExceptionReporter.class,</span><br><span class="line"><span class="keyword">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备上下文，会触发准备上下文事件</span></span><br><span class="line">prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">printedBanner);</span><br><span class="line"></span><br><span class="line"><span class="comment">//刷新上下文</span></span><br><span class="line">refreshContext(context);</span><br><span class="line"></span><br><span class="line">afterRefresh(context, applicationArguments);</span><br><span class="line">stopWatch.stop();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line"><span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</span><br><span class="line">.logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">&#125;</span><br><span class="line">listeners.started(context);</span><br><span class="line">callRunners(context, applicationArguments);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">listeners.running(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&lt;1&gt;详细解读待续。。。。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Dec 19 2019 15:09:44 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;从工作开始接触 
      
    
    </summary>
    
    
    
      <category term="springboot" scheme="https://zjcool.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>【redis命令介绍】-  client list</title>
    <link href="https://zjcool.github.io/2019/10/22/%E3%80%90redis%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%E3%80%91-client/"/>
    <id>https://zjcool.github.io/2019/10/22/【redis命令介绍】-client/</id>
    <published>2019-10-22T12:21:00.000Z</published>
    <updated>2019-10-22T12:37:08.257Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 19 2019 15:09:44 GMT+0800 (中国标准时间) --><p><code>client list</code> : 返回所有连接到服务器的客户端信息和统计数据</p><pre><code>返回值的含义：   * id: 唯一的64位的客户端ID(Redis 2.8.12加入)。* addr: 客户端的地址和端口* fd: 套接字所使用的文件描述符* age: 以秒计算的已连接时长* idle: 以秒计算的空闲时长* flags: 客户端 flag* db: 该客户端正在使用的数据库 ID* sub: 已订阅频道的数量* psub: 已订阅模式的数量* multi: 在事务中被执行的命令数量* qbuf: 查询缓冲区的长度（字节为单位， 0 表示没有分配查询缓冲区）* qbuf-free: 查询缓冲区剩余空间的长度（字节为单位， 0 表示没有剩余空间）* obl: 输出缓冲区的长度（字节为单位， 0 表示没有分配输出缓冲区）* oll: 输出列表包含的对象数量（当输出缓冲区没有剩余空间时，命令回复会以字符串对象的形式被入队到这个队列里）* omem: 输出缓冲区和输出列表占用的内存总量* events: 文件描述符事件* cmd: 最近一次执行的命令</code></pre><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Dec 19 2019 15:09:44 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;&lt;code&gt;client list&lt;/code&gt; : 返回所有连接到服务器的客户端信息和统计数据&lt;/p&gt;&lt;pre&gt;&lt;code&gt;返回值的含义：   
*
      
    
    </summary>
    
    
      <category term="redis" scheme="https://zjcool.github.io/categories/redis/"/>
    
    
      <category term="redis" scheme="https://zjcool.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>缓存问题及优化方案总结</title>
    <link href="https://zjcool.github.io/2019/10/22/redis%E7%BC%93%E5%AD%98/"/>
    <id>https://zjcool.github.io/2019/10/22/redis缓存/</id>
    <published>2019-10-22T10:05:00.000Z</published>
    <updated>2019-10-22T12:30:56.759Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 19 2019 15:09:44 GMT+0800 (中国标准时间) --><h2 id="缓存优化"><a href="#缓存优化" class="headerlink" title="缓存优化"></a>缓存优化</h2><h3 id="1-缓存穿透"><a href="#1-缓存穿透" class="headerlink" title="1. 缓存穿透"></a>1. 缓存穿透</h3><p>现象解释：大量出现查询一个根本不存在的数据，缓存层和存储层都不会命中。从而导致后端负载加大，甚至服务宕机。</p><h4 id="1-1-穿透优化方案"><a href="#1-1-穿透优化方案" class="headerlink" title="1.1 穿透优化方案"></a>1.1 穿透优化方案</h4><ol><li><p>缓存空对象+设置过期时间</p></li><li><p>缓存层之前加一个布隆过滤器（判断一定不存在，就不到缓存层去找了）<br>适用场景：数据命中不高、数据相对稳定、实时性低（通常数据集较大）的应用场景。</p></li></ol><h4 id="1-2-对比"><a href="#1-2-对比" class="headerlink" title="1.2 对比"></a>1.2 对比</h4><table><thead><tr><th>方案</th><th>适用场景</th><th>维护成本</th></tr></thead><tbody><tr><td>缓存空对象</td><td>数据命中不高、数据频繁变化</td><td>代码维护简单、需要更多缓存空间、数据源不一致</td></tr><tr><td>布隆过滤器</td><td>数据命中不高、数据相对固定、实时性低</td><td>代码维护复杂、缓存空间占用少</td></tr></tbody></table><hr><h3 id="2-无底洞"><a href="#2-无底洞" class="headerlink" title="2. 无底洞"></a>2. 无底洞</h3><p>现象解释：水平增加节点，性能不升，反而可能出现下降的情况。<br>可能原因分析：</p><ul><li>一次批量操作会涉及多次网络操作，随着节点增加，耗时增大</li><li>网络连接数变多，对节点性能存在一定的影响</li></ul><h4 id="2-1-无底洞优化思路"><a href="#2-1-无底洞优化思路" class="headerlink" title="2.1 无底洞优化思路"></a>2.1 无底洞优化思路</h4><ul><li>命令本身的优化，例如优化SQL</li><li>减少通信次数</li><li>降低接入成本，例如客户端使用长连接/连接池,NIO等</li></ul><h4 id="2-2-方案"><a href="#2-2-方案" class="headerlink" title="2.2 方案"></a>2.2 方案</h4><ul><li><p>串型io–单线程批量获取<br>问题：node 多，速度慢</p></li><li><p>并行io–多线程批量获取<br>问题：编程复杂，出问题，定位困难</p></li><li><p>hash_tag–让key集中在一台机器上<br>问题：业务维护成本高，可能导致数据倾斜</p></li></ul><hr><h3 id="3-缓存雪崩"><a href="#3-缓存雪崩" class="headerlink" title="3. 缓存雪崩"></a>3. 缓存雪崩</h3><p>现象解释：缓存层存在故障，导致所有请求直接请求数据存储层，从而导致存储层调用暴增，造成存储层也会级联宕机。</p><h4 id="3-1-优化思路（预防和解决）"><a href="#3-1-优化思路（预防和解决）" class="headerlink" title="3.1 优化思路（预防和解决）"></a>3.1 优化思路（预防和解决）</h4><ul><li><p>保证缓存层高可用</p></li><li><p>后端提供限流并降级实现</p></li><li><p>提前演练（预防+测试）</p></li></ul><hr><h3 id="4-热点key重建"><a href="#4-热点key重建" class="headerlink" title="4.热点key重建"></a>4.热点key重建</h3><p>现象解释：当前key是一个热点key，并发量非常大；同时，重建缓存不能在短时间内完成。因此，在缓存失效的瞬间，会有大量的线程开始重建缓存，导致后端负载过大。</p><h4 id="4-1-优化思路"><a href="#4-1-优化思路" class="headerlink" title="4.1 优化思路"></a>4.1 优化思路</h4><ul><li>减少重建缓存次数</li><li>数据尽可能一致</li><li>较少的潜在风险</li></ul><h4 id="4-2-优化方案"><a href="#4-2-优化方案" class="headerlink" title="4.2 优化方案"></a>4.2 优化方案</h4><ol><li><p>互斥锁<br>只允许一个线程重建缓存 —&gt; redis 中<code>setnx</code>命令</p></li><li><p>永远不过期<br>设置一个逻辑过期时间，和value一起存储，当发现key逻辑过期时间小于当前时间时，异步更新key（通过setnx 分布式锁，获取锁，就去异步更新），会出现数据不一致现象</p></li></ol><p>参考资料《Redis 开发与运维》</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Dec 19 2019 15:09:44 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;缓存优化&quot;&gt;&lt;a href=&quot;#缓存优化&quot; class=&quot;headerlink&quot; title=&quot;缓存优化&quot;&gt;&lt;/a&gt;缓存优化&lt;/h2&gt;&lt;h3
      
    
    </summary>
    
    
      <category term="缓存" scheme="https://zjcool.github.io/categories/%E7%BC%93%E5%AD%98/"/>
    
    
  </entry>
  
  <entry>
    <title>【JVM】- 调整Jvm参数SurvivorRatio思路</title>
    <link href="https://zjcool.github.io/2019/10/12/%E3%80%90java%E3%80%91-%E8%B0%83%E6%95%B4jvm%E6%80%9D%E8%B7%AF/"/>
    <id>https://zjcool.github.io/2019/10/12/【java】-调整jvm思路/</id>
    <published>2019-10-12T03:17:39.000Z</published>
    <updated>2019-10-12T04:07:45.781Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 19 2019 15:09:44 GMT+0800 (中国标准时间) --><p>关于Jvm的内存模型，网上资料很多，这里就不详细介绍了。</p><p>今天我首先想要分享的是如何调整eden区和Survivor区的比例，即：-XX:SurvivorRatio。（默认是8，即eden：from：to=8：1：1）</p><p>我们知道Jvm堆内存大小=年轻代+老年代，而年轻代=Eden+2*Survivor,那么如何设置他们的比例关系比较合理呢？</p><p><strong>我认为的核心思路：尽可能去减少gc次数。尤其full gc 次数</strong></p><p>我们知道eden区满的时候，会触发young gc，会对eden区和一块 Survivor-From区的内存进行GC，把gc后的存活的内容（超过一定年龄的升入老年代）放入另一块 Survivor-To 区中。如果To区不够，就直接放入老年代。</p><p>所以为了减少gc次数（young和full gc），应该让每次young gc的后存活的内容最大限度的放入To区，即最大限度的利用内存空间。</p><p>那么如何观察呢？</p><p>我们可以使用命令：<code>jstat -gcutil pid 5000</code> (5秒打印一次jvm信息（比例）) 观察 每次young gc后的 Survivor 区比例占用情况，如果 Survivor 的区每次都只有20-30%的占用比，那么可以适当的减小 Survivor 的大小 即调大 SurvivorRatio 。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Dec 19 2019 15:09:44 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;关于Jvm的内存模型，网上资料很多，这里就不详细介绍了。&lt;/p&gt;&lt;p&gt;今天我首先想要分享的是如何调整eden区和Survivor区的比例，即：-XX:
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>【java】- 定位cpu过高问题代码</title>
    <link href="https://zjcool.github.io/2019/10/12/%E3%80%90java%E3%80%91-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E6%AD%A5%E9%AA%A4/"/>
    <id>https://zjcool.github.io/2019/10/12/【java】-性能调优步骤/</id>
    <published>2019-10-12T02:48:00.000Z</published>
    <updated>2019-10-12T03:15:33.015Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 19 2019 15:09:44 GMT+0800 (中国标准时间) --><p>相信大家肯定遇到过java程序cpu一直居高不下的情况，那么我来简单介绍在linux系统下如何定位java进程cpu过高的代码位置。</p><p>首先，使用命令<code>top</code>,找到cpu过高的pid；</p><p>接着，使用<code>top -Hp pid</code> 找到对应的线程 tid；</p><p>我们知道<code>jstack</code>可以查看当前java进程的堆栈状态；由于线程在堆栈信息的使用16进制的。那么，<code>printf &quot;%x&quot; tid</code> 可以获取16进制的 tid16。</p><p>最后使用 <code>jstack pid |grep -A 10 tid16</code> ，根据情况调整行数后，就可以看到该线程是执行的代码。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Dec 19 2019 15:09:44 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;相信大家肯定遇到过java程序cpu一直居高不下的情况，那么我来简单介绍在linux系统下如何定位java进程cpu过高的代码位置。&lt;/p&gt;&lt;p&gt;首先
      
    
    </summary>
    
    
      <category term="java" scheme="https://zjcool.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>【K8s】- 揭秘K8s健康检查机制 LivenessProbe和ReadinessProbe</title>
    <link href="https://zjcool.github.io/2019/10/10/%E3%80%90K8s%E3%80%91-%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/"/>
    <id>https://zjcool.github.io/2019/10/10/【K8s】-健康检查机制/</id>
    <published>2019-10-10T07:35:00.000Z</published>
    <updated>2019-10-10T08:37:43.053Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 19 2019 15:09:44 GMT+0800 (中国标准时间) --><p>从接触k8s，到目前已经差不多一年时间了，但是对k8s的健康检查机制一直很模糊，今天对其进行了简单的研究，记录如下：</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>k8s的健康机制主要是通过两个探测机制：<strong>LivenessProbe</strong>和<strong>ReadinessProbe</strong>。</p><p><strong>LivenessProbe</strong>:用于判断容器是否存活（running状态），来确定是否需要重启容器。</p><p><strong>ReadinessProbe</strong>:用于判断容器是否启动完成（ready状态）,来确定是否可以接受流量（请求）。</p><h4 id="探测方式"><a href="#探测方式" class="headerlink" title="探测方式"></a>探测方式</h4><p>k8s是通过探测的方式来判断pod是否正常的，那么k8s支持的探测方式有哪些呢？其主要是以下三种：</p><ol><li><p>HTTP GET探针 对容器内的目标ip和端口发送HTTP GET请求。响应状态码是2xx或3xx 表示成功。</p></li><li><p>TCP 套接字探针 尝试建立TCP连接，成功建立则成功。</p></li><li><p>Exec探针，在容器内执行shell命令，根据返回结果判断是否成功。</p></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Dec 19 2019 15:09:44 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;从接触k8s，到目前已经差不多一年时间了，但是对k8s的健康检查机制一直很模糊，今天对其进行了简单的研究，记录如下：&lt;/p&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="K8s" scheme="https://zjcool.github.io/categories/K8s/"/>
    
    
  </entry>
  
  <entry>
    <title>【java】- 排查问题命令</title>
    <link href="https://zjcool.github.io/2019/10/08/%E3%80%90java%E6%8E%92%E6%9F%A5%E5%91%BD%E4%BB%A4%E3%80%91/"/>
    <id>https://zjcool.github.io/2019/10/08/【java排查命令】/</id>
    <published>2019-10-08T08:50:00.000Z</published>
    <updated>2019-11-21T08:19:53.096Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 19 2019 15:09:44 GMT+0800 (中国标准时间) --><ul><li>获取java程序的pid</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps -v</span><br></pre></td></tr></table></figure><ul><li>查看占用cpu最高线程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -Hp pid</span><br></pre></td></tr></table></figure><ul><li>查看某个线程的堆栈信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//获取 线程id的十六进制</span><br><span class="line">printf &quot;%x\n&quot; 线程id </span><br><span class="line">jstack pid |grep &lt;16进制&gt;</span><br></pre></td></tr></table></figure><ul><li>查看堆内存使用情况</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap pid</span><br></pre></td></tr></table></figure><ul><li>查看堆内存中的对象数目，大小</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -histo:live pid</span><br></pre></td></tr></table></figure><ul><li>统计jvm信息-查看gc信息（1000毫秒 4次）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -gc pid 1000 4</span><br></pre></td></tr></table></figure><ul><li><p>统计jvm信息-查看gc信息比例（1000毫秒 4次）<strong>重要</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -gcutil pid 1000 4</span><br></pre></td></tr></table></figure></li><li><p>dump heap 命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:live,format=b,file=heapLive.hprof pid</span><br></pre></td></tr></table></figure></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Dec 19 2019 15:09:44 GMT+0800 (中国标准时间) --&gt;&lt;ul&gt;&lt;li&gt;获取java程序的pid&lt;/li&gt;&lt;/ul&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zjcool.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>【排序算法】-  冒泡排序</title>
    <link href="https://zjcool.github.io/2019/09/26/%E3%80%90%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E3%80%91-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>https://zjcool.github.io/2019/09/26/【排序算法】-冒泡排序/</id>
    <published>2019-09-26T15:11:45.000Z</published>
    <updated>2019-10-08T08:49:07.128Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 19 2019 15:09:44 GMT+0800 (中国标准时间) --><p>是一个稳定的排序算法<br>最优时间复杂度O(n)，完全有序；<br>最差时间复杂度O(n^2)-逆序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 冒泡排序，a 表示数组，n 表示数组大小</span><br><span class="line">public void bubbleSort(int[] a, int n) &#123;</span><br><span class="line">  if (n &lt;= 1) return;</span><br><span class="line"> </span><br><span class="line"> for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">    // 提前退出冒泡循环的标志位</span><br><span class="line">    boolean flag = false;</span><br><span class="line">    for (int j = 0; j &lt; n - i - 1; ++j) &#123;</span><br><span class="line">      if (a[j] &gt; a[j+1]) &#123; // 交换</span><br><span class="line">        int tmp = a[j];</span><br><span class="line">        a[j] = a[j+1];</span><br><span class="line">        a[j+1] = tmp;</span><br><span class="line">        flag = true;  // 表示有数据交换      </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!flag) break;  // 没有数据交换，提前退出</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Dec 19 2019 15:09:44 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;是一个稳定的排序算法&lt;br&gt;最优时间复杂度O(n)，完全有序；&lt;br&gt;最差时间复杂度O(n^2)-逆序&lt;/p&gt;&lt;figure class=&quot;highl
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>【mac操作】-  制作系统盘以及恢复</title>
    <link href="https://zjcool.github.io/2019/09/25/%E3%80%90mac%E6%93%8D%E4%BD%9C%E3%80%91-%E5%88%B6%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%98%E4%BB%A5%E5%8F%8A%E6%81%A2%E5%A4%8D/"/>
    <id>https://zjcool.github.io/2019/09/25/【mac操作】-制作系统盘以及恢复/</id>
    <published>2019-09-25T07:55:00.000Z</published>
    <updated>2019-09-25T08:18:08.976Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 19 2019 15:09:44 GMT+0800 (中国标准时间) --><p>一、制作系统操作盘</p><ul><li>下载操作系统镜像iso</li><li>查看u盘 <code>diskutil list</code> , <code>/dev/disk2</code>是u盘</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">~ » diskutil list                                           </span><br><span class="line">/dev/disk0 (internal):</span><br><span class="line">   #:                       TYPE NAME                    SIZE       IDENTIFIER</span><br><span class="line">   0:      GUID_partition_scheme                         251.0 GB   disk0</span><br><span class="line">   1:                        EFI EFI                     314.6 MB   disk0s1</span><br><span class="line">   2:                 Apple_APFS Container disk1         250.7 GB   disk0s2</span><br><span class="line">/dev/disk1 (synthesized):</span><br><span class="line">   #:                       TYPE NAME                    SIZE       IDENTIFIER</span><br><span class="line">   0:      APFS Container Scheme -                      +250.7 GB   disk1</span><br><span class="line">                                 Physical Store disk0s2</span><br><span class="line">   1:                APFS Volume Macintosh HD            125.8 GB   disk1s1</span><br><span class="line">   2:                APFS Volume Preboot                 44.4 MB    disk1s2</span><br><span class="line">   3:                APFS Volume Recovery                509.7 MB   disk1s3</span><br><span class="line">   4:                APFS Volume VM                      9.7 GB     disk1s4</span><br><span class="line">/dev/disk2 (external, physical):</span><br><span class="line">   #:                       TYPE NAME                    SIZE       IDENTIFIER</span><br><span class="line">   0:      GUID_partition_scheme                        *15.9 GB    disk2</span><br><span class="line">   1:                        EFI EFI                     209.7 MB   disk2s1</span><br><span class="line">   2:       Microsoft Basic Data StarkyDisk              15.7 GB    disk2s2</span><br></pre></td></tr></table></figure><ul><li><p>解除u盘的挂载状态<br><code>diskutil unmountDisk /dev/disk2</code></p></li><li><p>写入u盘<br><code>sudo dd if=iso镜像路径 of=/dev/rdisk2 bs=1m rdisk</code></p></li></ul><p>二、恢复u盘</p><ul><li><code>diskutil eraseDisk ExFAT myDisk /dev/disk2</code></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Dec 19 2019 15:09:44 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;一、制作系统操作盘&lt;/p&gt;&lt;ul&gt;&lt;li&gt;下载操作系统镜像iso&lt;/li&gt;&lt;li&gt;查看u盘 &lt;code&gt;diskutil list&lt;/code&gt; , 
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://zjcool.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="mac" scheme="https://zjcool.github.io/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>【线上问题】-  记一次线上问题的解决方案</title>
    <link href="https://zjcool.github.io/2019/09/25/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://zjcool.github.io/2019/09/25/记一次线上问题解决方案/</id>
    <published>2019-09-25T06:38:00.000Z</published>
    <updated>2019-09-25T08:26:11.367Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 19 2019 15:09:44 GMT+0800 (中国标准时间) --><p><strong>未解决之前存在问题</strong></p><ol><li>老的java服务，源代码已经找不到了</li><li>客户需要的接口返回参数里 加了密，加密方式为AES</li><li>由于该秘钥在其他很多服务中都使用着，不能直接提供给客户使用</li><li>新的服务，还没有经过测试，无法直接上线，就算能获得测试资源，上线的时间也不能满足客户的需求</li></ol><p><strong>最终解决方案</strong><br>增加一个<strong>代理服务</strong>，去调用老的服务，把返回参数解密后返回给客户</p><p>优点：</p><ol><li>客户只需要换一下调用的服务端口即可</li><li>上线非常快（半个小时开发时间）</li><li>无需关心老的接口</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Dec 19 2019 15:09:44 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;&lt;strong&gt;未解决之前存在问题&lt;/strong&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;老的java服务，源代码已经找不到了&lt;/li&gt;&lt;li&gt;客户需要的接口返回参
      
    
    </summary>
    
    
      <category term="线上问题" scheme="https://zjcool.github.io/categories/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>【Java】-  获取当天剩余秒数</title>
    <link href="https://zjcool.github.io/2019/09/23/java%E2%80%94%E8%8E%B7%E5%8F%96%E5%BD%93%E5%A4%A9%E5%89%A9%E4%BD%99%E7%A7%92%E6%95%B0/"/>
    <id>https://zjcool.github.io/2019/09/23/java—获取当天剩余秒数/</id>
    <published>2019-09-23T15:11:00.000Z</published>
    <updated>2019-10-23T09:22:47.949Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 19 2019 15:09:44 GMT+0800 (中国标准时间) --><h4 id="获取当天剩余秒数"><a href="#获取当天剩余秒数" class="headerlink" title="获取当天剩余秒数"></a>获取当天剩余秒数</h4><p>两种方法<br>1.线程不安全</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static Integer getLeftTime() &#123;</span><br><span class="line">        Calendar midnight=Calendar.getInstance();</span><br><span class="line">        midnight.setTime(new Date());</span><br><span class="line">        midnight.add(Calendar.DAY_OF_MONTH,1);//加一天</span><br><span class="line">        midnight.set(Calendar.HOUR_OF_DAY,0);</span><br><span class="line">        midnight.set(Calendar.MINUTE,0);</span><br><span class="line">        midnight.set(Calendar.SECOND,0);</span><br><span class="line">        midnight.set(Calendar.MILLISECOND,0);</span><br><span class="line">        return (int)((midnight.getTime().getTime()-currentDate.getTime())/1000);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>2.线程安全</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    Date now = new Date();</span><br><span class="line">    LocalDateTime midnight = LocalDateTime.ofInstant(now.toInstant(), ZoneId.systemDefault()).plusDays(1)</span><br><span class="line">            .withHour(0)</span><br><span class="line">            .withMinute(0)</span><br><span class="line">            .withSecond(0)</span><br><span class="line">            .withNano(0);</span><br><span class="line">    LocalDateTime current = LocalDateTime.ofInstant(now.toInstant(), ZoneId.systemDefault());</span><br><span class="line">    return (int) ChronoUnit.SECONDS.between(current, midnight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Dec 19 2019 15:09:44 GMT+0800 (中国标准时间) --&gt;&lt;h4 id=&quot;获取当天剩余秒数&quot;&gt;&lt;a href=&quot;#获取当天剩余秒数&quot; class=&quot;headerlink&quot; title=&quot;获取当天剩余秒数&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zjcool.github.io/categories/Java/"/>
    
    
      <category term="Date" scheme="https://zjcool.github.io/tags/Date/"/>
    
  </entry>
  
  <entry>
    <title>【Java8】-  Predicate用法</title>
    <link href="https://zjcool.github.io/2019/09/19/Java8%E2%80%94Predicate%E7%94%A8%E6%B3%95/"/>
    <id>https://zjcool.github.io/2019/09/19/Java8—Predicate用法/</id>
    <published>2019-09-19T14:58:00.000Z</published>
    <updated>2019-09-25T08:27:14.217Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 19 2019 15:09:44 GMT+0800 (中国标准时间) --><blockquote><p>每次失眠，都要庆幸多了一次，可以深刻思考的机会！</p></blockquote><p>废话说完,直接上代码：</p><ul><li>筛选以字母c结尾的字符串</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;String&gt; condition2 = s -&gt; s.endsWith(&quot;c&quot;);</span><br></pre></td></tr></table></figure><ul><li>筛选以字母a开头的字符串</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;String&gt; condition1 = s -&gt; s.startsWith(&quot;a&quot;);</span><br><span class="line"></span><br><span class="line">boolean res1 = condition1.test(&quot;abc&quot;); //true</span><br><span class="line">//negate 取反的意思</span><br><span class="line">boolean res2 = condition1.negate().test(&quot;abc&quot;) //false</span><br></pre></td></tr></table></figure><ul><li>筛选以字母a开头 且 以字母c结尾的字符串</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;String&gt; and = condition.and(condition2);</span><br></pre></td></tr></table></figure><ul><li>筛选以字母a开头 或 以字母c结尾的字符串</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;String&gt; and = condition.or(condition2);</span><br></pre></td></tr></table></figure><ul><li>筛选大于3的数字</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;Integer&gt; condition2 = a -&gt; a &gt;=3;</span><br></pre></td></tr></table></figure><ul><li>遍历集合删除以a开头的字符串</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; res4 = list.stream().filter(condition1.negate()).collect(Collectors.toList(););</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Dec 19 2019 15:09:44 GMT+0800 (中国标准时间) --&gt;&lt;blockquote&gt;&lt;p&gt;每次失眠，都要庆幸多了一次，可以深刻思考的机会！&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;废话说完,直接上代码：&lt;/p&gt;&lt;ul&gt;
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zjcool.github.io/categories/Java/"/>
    
    
      <category term="Predicate" scheme="https://zjcool.github.io/tags/Predicate/"/>
    
  </entry>
  
  <entry>
    <title>【Lamada】-  遍历过滤</title>
    <link href="https://zjcool.github.io/2019/09/19/Lamada%E2%80%94%E9%81%8D%E5%8E%86%E8%BF%87%E6%BB%A4/"/>
    <id>https://zjcool.github.io/2019/09/19/Lamada—遍历过滤/</id>
    <published>2019-09-19T13:31:00.000Z</published>
    <updated>2019-09-25T08:09:20.512Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 19 2019 15:09:44 GMT+0800 (中国标准时间) --><p>java8以前，想对list集合进行过滤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//不要用Arrays.asList,迭代器删除会失败</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;(3);</span><br><span class="line">list.add(&quot;abc&quot;);</span><br><span class="line">list.add(&quot;bbc&quot;);</span><br><span class="line">list.add(&quot;cbc&quot;);</span><br><span class="line"></span><br><span class="line">//过滤以字母 a 开头的字符串</span><br><span class="line">List&lt;String&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">for (String s : list) &#123;</span><br><span class="line">    if (!s.startsWith(&quot;a&quot;)) &#123;</span><br><span class="line">        res.add(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//或者这样</span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">    String next = it.next();</span><br><span class="line">    if (next.startsWith(&quot;a&quot;)) &#123;</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java8使用lamada实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; res = list.stream().filter(s -&gt; !s.startsWith(&quot;a&quot;)).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Dec 19 2019 15:09:44 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;java8以前，想对list集合进行过滤&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zjcool.github.io/categories/Java/"/>
    
    
      <category term="Lamada" scheme="https://zjcool.github.io/tags/Lamada/"/>
    
  </entry>
  
  <entry>
    <title>【Lamada】-  实现runnable</title>
    <link href="https://zjcool.github.io/2019/09/19/Lamada%E2%80%94%E5%AE%9E%E7%8E%B0runnable/"/>
    <id>https://zjcool.github.io/2019/09/19/Lamada—实现runnable/</id>
    <published>2019-09-19T13:05:00.000Z</published>
    <updated>2019-09-25T08:09:32.504Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 19 2019 15:09:44 GMT+0800 (中国标准时间) --><p>在 Java8 之前开一个新的线程执行任务,具体代码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//java8 之前</span><br><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">             @Override</span><br><span class="line">             public void run() &#123;</span><br><span class="line">                 System.out.println(&quot;开一个新的线程，执行任务了&quot;);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;).start();</span><br></pre></td></tr></table></figure><p>而java8 提供了lamada表达式，我们可以这样实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Thread(() -&gt; System.out.println(&quot;开一个新的线程，执行任务了&quot;)).start();</span><br></pre></td></tr></table></figure><p>怎么样，这样的匿名内部实现是不是非常的简单呢！</p><p><strong>补充</strong>：<br>Calculate 是一个接口，里面有一个接口方法cal。如果你想实现该接口，但又不想建一个新的类，可以写成如下这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Calculate calculate = (int a, int b) -&gt; a + b;</span><br><span class="line">calculate.cal(1,2);</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Dec 19 2019 15:09:44 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;在 Java8 之前开一个新的线程执行任务,具体代码实现如下：&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zjcool.github.io/categories/Java/"/>
    
    
      <category term="Lamada" scheme="https://zjcool.github.io/tags/Lamada/"/>
    
  </entry>
  
  <entry>
    <title>【k8s】-  常用命令</title>
    <link href="https://zjcool.github.io/2019/09/17/K8S-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://zjcool.github.io/2019/09/17/K8S-常用命令/</id>
    <published>2019-09-17T14:22:00.000Z</published>
    <updated>2019-10-10T08:40:21.642Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 19 2019 15:09:44 GMT+0800 (中国标准时间) --><p>一、POD级别的操作</p><ul><li><p>获取kube-system命名空间下的所有pod(详细)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get po -nkube-system（-o wide）</span><br></pre></td></tr></table></figure></li><li><p>获取kube-system命名空间下名为<code>app1</code>的pod的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe po app1 -nkube-system</span><br></pre></td></tr></table></figure></li><li><p>删除kube-system命名空间下名为<code>app1</code>的pod</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete po app1 -nkube-system</span><br></pre></td></tr></table></figure></li><li><p>获取kube-system命名空间下名为<code>app1</code>的pod的日志信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs app1 -nkube-system</span><br></pre></td></tr></table></figure></li></ul><hr><p>二、Deploy级别的操作</p><ul><li><p>获取kube-system命名空间下的所有deploy(详细)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get deploy -n kube-system（-o wide）</span><br></pre></td></tr></table></figure></li><li><p>编辑kube-system命名空间下的名为<code>deployA</code> 的deploy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl edit deploy deployA -n kube-system</span><br></pre></td></tr></table></figure></li><li><p>更新kube-system命名空间下名为<code>deployA</code>里容器<code>app1</code>的镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl set image deploy deployA app1=nginx:1.9.1</span><br></pre></td></tr></table></figure></li><li><p>修改kube-system命名空间下名为<code>deployA</code>里容器<code>app1</code>的资源限制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl set resources deploy deployA -c=app1 --limits=cpu=200m,memory=512Mi</span><br></pre></td></tr></table></figure></li><li><p>修改kube-system命名空间下名为<code>deployA</code>所有容器的资源限制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl set resources deploy deployA· --limits=cpu=200m,memory=512Mi</span><br></pre></td></tr></table></figure></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Dec 19 2019 15:09:44 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;一、POD级别的操作&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;获取kube-system命名空间下的所有pod(详细)&lt;/p&gt;&lt;figure class=&quot;hig
      
    
    </summary>
    
    
      <category term="K8s" scheme="https://zjcool.github.io/categories/K8s/"/>
    
    
      <category term="k8s" scheme="https://zjcool.github.io/tags/k8s/"/>
    
      <category term="kubernetes" scheme="https://zjcool.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>【Lamada】-  List转Map</title>
    <link href="https://zjcool.github.io/2019/09/17/Lamada-List-Map/"/>
    <id>https://zjcool.github.io/2019/09/17/Lamada-List-Map/</id>
    <published>2019-09-17T12:29:00.000Z</published>
    <updated>2019-09-25T08:09:50.659Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 19 2019 15:09:44 GMT+0800 (中国标准时间) --><p>List to Map 一般可以分为以下几种情况:</p><ol><li>分组</li><li>去重</li></ol><p><strong>User.java</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import lombok.AllArgsConstructor;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.function.Function;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">public class User &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line">    private Integer grade;</span><br><span class="line"></span><br><span class="line">    private String sex;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;User&gt; users =new ArrayList&lt;&gt;();</span><br><span class="line">        users.add(new User(&quot;zhangsan&quot;,18,90,&quot;男&quot;));</span><br><span class="line">        users.add(new User(&quot;zhangsan&quot;,19,90,&quot;男&quot;));</span><br><span class="line">        users.add(new User(&quot;lisi&quot;,19,91,&quot;女&quot;));</span><br><span class="line">        //list to map</span><br><span class="line">        //1.分组，按照姓名分组</span><br><span class="line">        Map&lt;String, List&lt;User&gt;&gt; listMap = users.stream().collect(</span><br><span class="line">                Collectors.groupingBy(User::getName));</span><br><span class="line"></span><br><span class="line">        //2.分组统计 男女</span><br><span class="line">        Map&lt;String, Long&gt; collect = users.stream().collect(</span><br><span class="line">                Collectors.groupingBy(User::getSex, Collectors.counting())</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        //3.去重，根据年纪，后面的替换前面的，不加会跑出异常</span><br><span class="line">        Map&lt;Integer, User&gt; userMap = users.stream().collect(</span><br><span class="line">                        Collectors.toMap(</span><br><span class="line">                        User::getAge, Function.identity(),</span><br><span class="line">                        (oldUser, newUser) -&gt; newUser));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Dec 19 2019 15:09:44 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;List to Map 一般可以分为以下几种情况:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;分组&lt;/li&gt;&lt;li&gt;去重&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;User
      
    
    </summary>
    
    
      <category term="Java" scheme="https://zjcool.github.io/categories/Java/"/>
    
    
      <category term="Lamada" scheme="https://zjcool.github.io/tags/Lamada/"/>
    
  </entry>
  
</feed>
