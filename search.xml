<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【jdk源码解读系列一】-- ArrayList]]></title>
    <url>%2F2019%2F12%2F18%2F%E3%80%90jdk%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%91-ArrayList%2F</url>
    <content type="text"><![CDATA[【jdk源码解读系列一】– ArrayList今天来分享自己阅读ArrayList源码的记录（基于jdk8）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124package java.util;import java.util.function.Consumer;import java.util.function.Predicate;import java.util.function.UnaryOperator;import sun.misc.SharedSecrets;public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; private static final long serialVersionUID = 8683452581122892189L; //默认长度10 private static final int DEFAULT_CAPACITY = 10; // 当初始化大小为0的实现 --- new ArrayList(0) 或者 new ArrayList(collection),而 collection.size=0 private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; //不指定初始化的的实现 ---- new ArrayList() private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; // 实际存储数据的。添加第一个数据，直接将数组大小转为 DEFAULT_CAPACITY（不会被序列化） transient Object[] elementData; // non-private to simplify nested class access //arrayList 已包含数据大小 private int size; // 带初始大小的构造方法 public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125; &#125; // 空构造方法 public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; // 传入Collection的构造方法 public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; // 优化结构，减小空间，转变为size大小的数组 public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125; &#125; // 确保 指定大小的存储能力 的 集合 --最小大小10，设置小于10无效 public void ensureCapacity(int minCapacity) &#123; int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It's already // supposed to be at default size. : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125; &#125; //计算存储能力？？ private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity; &#125; private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); &#125; //确保集合 能达到指定大小的存储能力 private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; // 最大的集合大小 private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; //确保集合 能达到指定大小的存储能力 具体实现-----自动扩容核心 private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; //扩容一次 1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 如果还是小于，直接改为传进来的值 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; // private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; // 判断是否包含 public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0; &#125; // 返回 集合中第一个o的数组位置,如果没有，返回-1 public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; // 返回 集合中最后一个o的数组位置,如果没有，返回-1 public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; // 浅克隆 public Object clone() &#123; try &#123; ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(e); &#125; &#125; // 转为数组，底层是创建了一个新的数组返回，调用的是本地方法 public Object[] toArray() &#123; return Arrays.copyOf(elementData, size); &#125; //返回特定类型的数组，如果给定数组大小大于集合，那么之后的都设置为null @SuppressWarnings("unchecked") public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // Make a new array of a's runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; &#125; // Positional Access Operations @SuppressWarnings("unchecked") E elementData(int index) &#123; return (E) elementData[index]; &#125; //返回索引对应的存储值 public E get(int index) &#123; rangeCheck(index); return elementData(index); &#125; //设置值 返回旧值 public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; &#125; //在尾部添加值 public boolean add(E e) &#123; //自动扩容 ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; // 指定位置添加值, 当前值以及之后的值 往后挪一位 public void add(int index, E element) &#123; //范围检查 rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! //当前值和之后的值 往后挪一位 System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; // 删除索引对应的值，返回移除的值，所有索引后的值，向前移动一位 public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; &#125; //删除值，如果存在，移除第一个，返回true，如果不存在，返回false public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; // 删除索引对应的值 只是不返回删除的值 private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125; // 清空集合 public void clear() &#123; modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125; //在集合尾部添加集合 public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; // 在特定位置添加集合 public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; &#125; //删除集合一个索引范围的值 protected void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = size - toIndex; //将 toIndex 之后的值 依次从 fromIndex位置开始复制 System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // clear to let GC do its work int newSize = size - (toIndex-fromIndex); for (int i = newSize; i &lt; size; i++) &#123; elementData[i] = null; &#125; size = newSize; &#125; //越界检查 private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; // 越界检查 === A version of rangeCheck used by add and addAll./ private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; // 越界异常信息 private String outOfBoundsMsg(int index) &#123; return "Index: "+index+", Size: "+size; &#125; //删除集合中 包括c集合中的内容 A-B public boolean removeAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, false); &#125; //返回 A和B的交集 public boolean retainAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, true); &#125; private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; final Object[] elementData = this.elementData; int r = 0, w = 0; boolean modified = false; try &#123; for (; r &lt; size; r++) if (c.contains(elementData[r]) == complement) elementData[w++] = elementData[r]; &#125; finally &#123; // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. if (r != size) &#123; System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; &#125; if (w != size) &#123; // clear to let GC do its work for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; &#125; &#125; return modified; &#125; /** * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that * is, serialize it). * * @serialData The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt; * instance is emitted (int), followed by all of its elements * (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order. */ private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; /** * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is, * deserialize it). */ private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity int capacity = calculateCapacity(elementData, size); SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity); ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125; &#125; /** * Returns a list iterator over the elements in this list (in proper * sequence), starting at the specified position in the list. * The specified index indicates the first element that would be * returned by an initial call to &#123;@link ListIterator#next next&#125;. * An initial call to &#123;@link ListIterator#previous previous&#125; would * return the element with the specified index minus one. * * &lt;p&gt;The returned list iterator is &lt;a href="#fail-fast"&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;. * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public ListIterator&lt;E&gt; listIterator(int index) &#123; if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException("Index: "+index); return new ListItr(index); &#125; /** * Returns a list iterator over the elements in this list (in proper * sequence). * * &lt;p&gt;The returned list iterator is &lt;a href="#fail-fast"&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;. * * @see #listIterator(int) */ public ListIterator&lt;E&gt; listIterator() &#123; return new ListItr(0); &#125; /** * Returns an iterator over the elements in this list in proper sequence. * * &lt;p&gt;The returned iterator is &lt;a href="#fail-fast"&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;. * * @return an iterator over the elements in this list in proper sequence */ public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; /** * An optimized version of AbstractList.Itr */ private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; Itr() &#123;&#125; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings("unchecked") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings("unchecked") public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; /** * An optimized version of AbstractList.ListItr */ private class ListItr extends Itr implements ListIterator&lt;E&gt; &#123; ListItr(int index) &#123; super(); cursor = index; &#125; public boolean hasPrevious() &#123; return cursor != 0; &#125; public int nextIndex() &#123; return cursor; &#125; public int previousIndex() &#123; return cursor - 1; &#125; @SuppressWarnings("unchecked") public E previous() &#123; checkForComodification(); int i = cursor - 1; if (i &lt; 0) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i; return (E) elementData[lastRet = i]; &#125; public void set(E e) &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.set(lastRet, e); &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; public void add(E e) &#123; checkForComodification(); try &#123; int i = cursor; ArrayList.this.add(i, e); cursor = i + 1; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; &#125; /** * Returns a view of the portion of this list between the specified * &#123;@code fromIndex&#125;, inclusive, and &#123;@code toIndex&#125;, exclusive. (If * &#123;@code fromIndex&#125; and &#123;@code toIndex&#125; are equal, the returned list is * empty.) The returned list is backed by this list, so non-structural * changes in the returned list are reflected in this list, and vice-versa. * The returned list supports all of the optional list operations. * * &lt;p&gt;This method eliminates the need for explicit range operations (of * the sort that commonly exist for arrays). Any operation that expects * a list can be used as a range operation by passing a subList view * instead of a whole list. For example, the following idiom * removes a range of elements from a list: * &lt;pre&gt; * list.subList(from, to).clear(); * &lt;/pre&gt; * Similar idioms may be constructed for &#123;@link #indexOf(Object)&#125; and * &#123;@link #lastIndexOf(Object)&#125;, and all of the algorithms in the * &#123;@link Collections&#125; class can be applied to a subList. * * &lt;p&gt;The semantics of the list returned by this method become undefined if * the backing list (i.e., this list) is &lt;i&gt;structurally modified&lt;/i&gt; in * any way other than via the returned list. (Structural modifications are * those that change the size of this list, or otherwise perturb it in such * a fashion that iterations in progress may yield incorrect results.) * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; * @throws IllegalArgumentException &#123;@inheritDoc&#125; */ public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; subListRangeCheck(fromIndex, toIndex, size); return new SubList(this, 0, fromIndex, toIndex); &#125; static void subListRangeCheck(int fromIndex, int toIndex, int size) &#123; if (fromIndex &lt; 0) throw new IndexOutOfBoundsException("fromIndex = " + fromIndex); if (toIndex &gt; size) throw new IndexOutOfBoundsException("toIndex = " + toIndex); if (fromIndex &gt; toIndex) throw new IllegalArgumentException("fromIndex(" + fromIndex + ") &gt; toIndex(" + toIndex + ")"); &#125; private class SubList extends AbstractList&lt;E&gt; implements RandomAccess &#123; private final AbstractList&lt;E&gt; parent; private final int parentOffset; private final int offset; int size; SubList(AbstractList&lt;E&gt; parent, int offset, int fromIndex, int toIndex) &#123; this.parent = parent; this.parentOffset = fromIndex; this.offset = offset + fromIndex; this.size = toIndex - fromIndex; this.modCount = ArrayList.this.modCount; &#125; public E set(int index, E e) &#123; rangeCheck(index); checkForComodification(); E oldValue = ArrayList.this.elementData(offset + index); ArrayList.this.elementData[offset + index] = e; return oldValue; &#125; public E get(int index) &#123; rangeCheck(index); checkForComodification(); return ArrayList.this.elementData(offset + index); &#125; public int size() &#123; checkForComodification(); return this.size; &#125; public void add(int index, E e) &#123; rangeCheckForAdd(index); checkForComodification(); parent.add(parentOffset + index, e); this.modCount = parent.modCount; this.size++; &#125; public E remove(int index) &#123; rangeCheck(index); checkForComodification(); E result = parent.remove(parentOffset + index); this.modCount = parent.modCount; this.size--; return result; &#125; protected void removeRange(int fromIndex, int toIndex) &#123; checkForComodification(); parent.removeRange(parentOffset + fromIndex, parentOffset + toIndex); this.modCount = parent.modCount; this.size -= toIndex - fromIndex; &#125; public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(this.size, c); &#125; public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); int cSize = c.size(); if (cSize==0) return false; checkForComodification(); parent.addAll(parentOffset + index, c); this.modCount = parent.modCount; this.size += cSize; return true; &#125; public Iterator&lt;E&gt; iterator() &#123; return listIterator(); &#125; public ListIterator&lt;E&gt; listIterator(final int index) &#123; checkForComodification(); rangeCheckForAdd(index); final int offset = this.offset; return new ListIterator&lt;E&gt;() &#123; int cursor = index; int lastRet = -1; int expectedModCount = ArrayList.this.modCount; public boolean hasNext() &#123; return cursor != SubList.this.size; &#125; @SuppressWarnings("unchecked") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= SubList.this.size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (offset + i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[offset + (lastRet = i)]; &#125; public boolean hasPrevious() &#123; return cursor != 0; &#125; @SuppressWarnings("unchecked") public E previous() &#123; checkForComodification(); int i = cursor - 1; if (i &lt; 0) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (offset + i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i; return (E) elementData[offset + (lastRet = i)]; &#125; @SuppressWarnings("unchecked") public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = SubList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (offset + i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[offset + (i++)]); &#125; // update once at end of iteration to reduce heap write traffic lastRet = cursor = i; checkForComodification(); &#125; public int nextIndex() &#123; return cursor; &#125; public int previousIndex() &#123; return cursor - 1; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; SubList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = ArrayList.this.modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; public void set(E e) &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.set(offset + lastRet, e); &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; public void add(E e) &#123; checkForComodification(); try &#123; int i = cursor; SubList.this.add(i, e); cursor = i + 1; lastRet = -1; expectedModCount = ArrayList.this.modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (expectedModCount != ArrayList.this.modCount) throw new ConcurrentModificationException(); &#125; &#125;; &#125; public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; subListRangeCheck(fromIndex, toIndex, size); return new SubList(this, offset, fromIndex, toIndex); &#125; private void rangeCheck(int index) &#123; if (index &lt; 0 || index &gt;= this.size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; private void rangeCheckForAdd(int index) &#123; if (index &lt; 0 || index &gt; this.size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; private String outOfBoundsMsg(int index) &#123; return "Index: "+index+", Size: "+this.size; &#125; private void checkForComodification() &#123; if (ArrayList.this.modCount != this.modCount) throw new ConcurrentModificationException(); &#125; public Spliterator&lt;E&gt; spliterator() &#123; checkForComodification(); return new ArrayListSpliterator&lt;E&gt;(ArrayList.this, offset, offset + this.size, this.modCount); &#125; &#125; @Override public void forEach(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); final int expectedModCount = modCount; @SuppressWarnings("unchecked") final E[] elementData = (E[]) this.elementData; final int size = this.size; for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; action.accept(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; /** * Creates a &lt;em&gt;&lt;a href="Spliterator.html#binding"&gt;late-binding&lt;/a&gt;&lt;/em&gt; * and &lt;em&gt;fail-fast&lt;/em&gt; &#123;@link Spliterator&#125; over the elements in this * list. * * &lt;p&gt;The &#123;@code Spliterator&#125; reports &#123;@link Spliterator#SIZED&#125;, * &#123;@link Spliterator#SUBSIZED&#125;, and &#123;@link Spliterator#ORDERED&#125;. * Overriding implementations should document the reporting of additional * characteristic values. * * @return a &#123;@code Spliterator&#125; over the elements in this list * @since 1.8 */ @Override public Spliterator&lt;E&gt; spliterator() &#123; return new ArrayListSpliterator&lt;&gt;(this, 0, -1, 0); &#125; /** Index-based split-by-two, lazily initialized Spliterator */ static final class ArrayListSpliterator&lt;E&gt; implements Spliterator&lt;E&gt; &#123; /* * If ArrayLists were immutable, or structurally immutable (no * adds, removes, etc), we could implement their spliterators * with Arrays.spliterator. Instead we detect as much * interference during traversal as practical without * sacrificing much performance. We rely primarily on * modCounts. These are not guaranteed to detect concurrency * violations, and are sometimes overly conservative about * within-thread interference, but detect enough problems to * be worthwhile in practice. To carry this out, we (1) lazily * initialize fence and expectedModCount until the latest * point that we need to commit to the state we are checking * against; thus improving precision. (This doesn't apply to * SubLists, that create spliterators with current non-lazy * values). (2) We perform only a single * ConcurrentModificationException check at the end of forEach * (the most performance-sensitive method). When using forEach * (as opposed to iterators), we can normally only detect * interference after actions, not before. Further * CME-triggering checks apply to all other possible * violations of assumptions for example null or too-small * elementData array given its size(), that could only have * occurred due to interference. This allows the inner loop * of forEach to run without any further checks, and * simplifies lambda-resolution. While this does entail a * number of checks, note that in the common case of * list.stream().forEach(a), no checks or other computation * occur anywhere other than inside forEach itself. The other * less-often-used methods cannot take advantage of most of * these streamlinings. */ private final ArrayList&lt;E&gt; list; private int index; // current index, modified on advance/split private int fence; // -1 until used; then one past last index private int expectedModCount; // initialized when fence set /** Create new spliterator covering the given range */ ArrayListSpliterator(ArrayList&lt;E&gt; list, int origin, int fence, int expectedModCount) &#123; this.list = list; // OK if null unless traversed this.index = origin; this.fence = fence; this.expectedModCount = expectedModCount; &#125; private int getFence() &#123; // initialize fence to size on first use int hi; // (a specialized variant appears in method forEach) ArrayList&lt;E&gt; lst; if ((hi = fence) &lt; 0) &#123; if ((lst = list) == null) hi = fence = 0; else &#123; expectedModCount = lst.modCount; hi = fence = lst.size; &#125; &#125; return hi; &#125; public ArrayListSpliterator&lt;E&gt; trySplit() &#123; int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; return (lo &gt;= mid) ? null : // divide range in half unless too small new ArrayListSpliterator&lt;E&gt;(list, lo, index = mid, expectedModCount); &#125; public boolean tryAdvance(Consumer&lt;? super E&gt; action) &#123; if (action == null) throw new NullPointerException(); int hi = getFence(), i = index; if (i &lt; hi) &#123; index = i + 1; @SuppressWarnings("unchecked") E e = (E)list.elementData[i]; action.accept(e); if (list.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; &#125; return false; &#125; public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; int i, hi, mc; // hoist accesses and checks from loop ArrayList&lt;E&gt; lst; Object[] a; if (action == null) throw new NullPointerException(); if ((lst = list) != null &amp;&amp; (a = lst.elementData) != null) &#123; if ((hi = fence) &lt; 0) &#123; mc = lst.modCount; hi = lst.size; &#125; else mc = expectedModCount; if ((i = index) &gt;= 0 &amp;&amp; (index = hi) &lt;= a.length) &#123; for (; i &lt; hi; ++i) &#123; @SuppressWarnings("unchecked") E e = (E) a[i]; action.accept(e); &#125; if (lst.modCount == mc) return; &#125; &#125; throw new ConcurrentModificationException(); &#125; public long estimateSize() &#123; return (long) (getFence() - index); &#125; public int characteristics() &#123; return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED; &#125; &#125; @Override public boolean removeIf(Predicate&lt;? super E&gt; filter) &#123; Objects.requireNonNull(filter); // figure out which elements are to be removed // any exception thrown from the filter predicate at this stage // will leave the collection unmodified int removeCount = 0; final BitSet removeSet = new BitSet(size); final int expectedModCount = modCount; final int size = this.size; for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; @SuppressWarnings("unchecked") final E element = (E) elementData[i]; if (filter.test(element)) &#123; removeSet.set(i); removeCount++; &#125; &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; // shift surviving elements left over the spaces left by removed elements final boolean anyToRemove = removeCount &gt; 0; if (anyToRemove) &#123; final int newSize = size - removeCount; for (int i=0, j=0; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) &#123; i = removeSet.nextClearBit(i); elementData[j] = elementData[i]; &#125; for (int k=newSize; k &lt; size; k++) &#123; elementData[k] = null; // Let gc do its work &#125; this.size = newSize; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++; &#125; return anyToRemove; &#125; @Override @SuppressWarnings("unchecked") public void replaceAll(UnaryOperator&lt;E&gt; operator) &#123; Objects.requireNonNull(operator); final int expectedModCount = modCount; final int size = this.size; for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; elementData[i] = operator.apply((E) elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++; &#125; @Override @SuppressWarnings("unchecked") public void sort(Comparator&lt;? super E&gt; c) &#123; final int expectedModCount = modCount; Arrays.sort((E[]) elementData, 0, size, c); if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++; &#125;&#125;]]></content>
      <tags>
        <tag>jdk源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【springboot源码解析】-- 解读过程一]]></title>
    <url>%2F2019%2F11%2F19%2F%E3%80%90springboot%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%91-SpringApplication%2F</url>
    <content type="text"><![CDATA[概述从工作开始接触 springboot 到现在将近过去两年时光了，虽偶然看看springboot启动源码，但从未仔细研读深究过，网上虽然有很多源码解析，但是每次读几篇就会因为各种原因半途而止，这次准备花一点时间好好将底层源码研究一番。好了，废话就不多说了，我们正式开始 springboot 之旅吧!请看下面代码吧：12345678@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125;想必大家对上面的代码都不会陌生，任何一个 springboot 服务都是由此方法开始启动的，开始一个个来解释。@SpringBootApplication 注解官方给出的解释是This is a convenience annotation that is equivalent to declaring {@code @Configuration}, {@code @EnableAutoConfiguration} and {@code @ComponentScan}.也就是说 @SpringBootApplication 是 @Configuration、@EnableAutoConfiguration、@ComponentScan 三个注解的组合注解。想详细了解这三个注解的含义，可以阅读以下文章：深入理解 – @Configuration 注解深入理解 – @EnableAutoConfiguration 注解深入理解 – @ComponentScan 注解主函数主函数依次执行step 1：1SpringApplication.run(Application.class, args);step 2：1234public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) &#123; return new SpringApplication(primarySources).run(args); &#125;primarySources 就是 Application.classstep 3：开始执行的 SpringApplication 的构造方法1234567891011121314public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123; this.resourceLoader = resourceLoader; Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;); this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources)); //&lt;1&gt; 从classPath中推测当前应用是什么类型的应用， this.webApplicationType = WebApplicationType.deduceFromClasspath(); //&lt;2&gt; 设置 spring 容器的初始化器（ApplicationContextInitializer） setInitializers((Collection) getSpringFactoriesInstances( ApplicationContextInitializer.class)); // &lt;3&gt;设置 spring 容器的监听器 setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); // 设置主类，即 Application.class this.mainApplicationClass = deduceMainApplicationClass(); &#125;&lt;1&gt; WebApplicationType类型包括 SERVLET、REACTIVE、NONE，后面会根据不同的类型，以不同的方式来启动服务&lt;2&gt;会从 spring-boot 和 spring-boot-autoconfigure 的jar包里的META-INF/spring.factories 中加载所有的 ApplicationContextInitializer 作为 spring 容器的初始化器 ApplicationContextInitializer&lt;3&gt; 会从 spring-boot 和spring-boot-autoconfigure 的jar包里的META-INF/spring.factories 中加载所有的 Listenerstep 4： 开始运行Spring 应用，刷新上下文这一步内容有点多，请耐心查看12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//SpringApptionlication.java// springboot 启动过程public ConfigurableApplicationContext run(String... args) &#123; // stopWatch 是一个计算代码时间的类 StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; //异常收集容器 Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;(); // 开启无设备鼠标键盘模式（需要提供一些（设备）信息给客户端） configureHeadlessProperty(); // 反射生成 SpringApplicationRunListener 的实现类----&gt; EventPublishingRunListener 即获取Spring启动监听器 SpringApplicationRunListeners listeners = getRunListeners(args); // 触发 ApplicationStartingEvent 事件，执行对应动作 listeners.starting(); try &#123; // 获取环境配置 ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); // &lt;1&gt;生成环境配置+设置环境变量 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); // 忽略的配置的 bean configureIgnoreBeanInfo(environment); //输出banner Banner printedBanner = printBanner(environment); //生成应用上下文（这里会生成基于注解的 AnnotationConfigServletWebServerApplicationContext） context = createApplicationContext(); // 反射生产一些异常收集器 exceptionReporters = getSpringFactoriesInstances( SpringBootExceptionReporter.class, new Class[] &#123; ConfigurableApplicationContext.class &#125;, context); //准备上下文，会触发准备上下文事件 prepareContext(context, environment, listeners, applicationArguments, printedBanner); //刷新上下文 refreshContext(context); afterRefresh(context, applicationArguments); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; listeners.started(context); callRunners(context, applicationArguments); &#125; catch (Throwable ex) &#123; handleRunFailure(context, ex, exceptionReporters, listeners); throw new IllegalStateException(ex); &#125; try &#123; listeners.running(context); &#125; catch (Throwable ex) &#123; handleRunFailure(context, ex, exceptionReporters, null); throw new IllegalStateException(ex); &#125; return context; &#125;&lt;1&gt;]]></content>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【redis命令介绍】- client list]]></title>
    <url>%2F2019%2F10%2F22%2F%E3%80%90redis%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%E3%80%91-client%2F</url>
    <content type="text"><![CDATA[client list : 返回所有连接到服务器的客户端信息和统计数据返回值的含义： * id: 唯一的64位的客户端ID(Redis 2.8.12加入)。 * addr: 客户端的地址和端口 * fd: 套接字所使用的文件描述符 * age: 以秒计算的已连接时长 * idle: 以秒计算的空闲时长 * flags: 客户端 flag * db: 该客户端正在使用的数据库 ID * sub: 已订阅频道的数量 * psub: 已订阅模式的数量 * multi: 在事务中被执行的命令数量 * qbuf: 查询缓冲区的长度（字节为单位， 0 表示没有分配查询缓冲区） * qbuf-free: 查询缓冲区剩余空间的长度（字节为单位， 0 表示没有剩余空间） * obl: 输出缓冲区的长度（字节为单位， 0 表示没有分配输出缓冲区） * oll: 输出列表包含的对象数量（当输出缓冲区没有剩余空间时，命令回复会以字符串对象的形式被入队到这个队列里） * omem: 输出缓冲区和输出列表占用的内存总量 * events: 文件描述符事件 * cmd: 最近一次执行的命令]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[缓存问题及优化方案总结]]></title>
    <url>%2F2019%2F10%2F22%2Fredis%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[缓存优化1. 缓存穿透现象解释：大量出现查询一个根本不存在的数据，缓存层和存储层都不会命中。从而导致后端负载加大，甚至服务宕机。1.1 穿透优化方案缓存空对象+设置过期时间缓存层之前加一个布隆过滤器（判断一定不存在，就不到缓存层去找了）适用场景：数据命中不高、数据相对稳定、实时性低（通常数据集较大）的应用场景。1.2 对比方案适用场景维护成本缓存空对象数据命中不高、数据频繁变化代码维护简单、需要更多缓存空间、数据源不一致布隆过滤器数据命中不高、数据相对固定、实时性低代码维护复杂、缓存空间占用少2. 无底洞现象解释：水平增加节点，性能不升，反而可能出现下降的情况。可能原因分析：一次批量操作会涉及多次网络操作，随着节点增加，耗时增大网络连接数变多，对节点性能存在一定的影响2.1 无底洞优化思路命令本身的优化，例如优化SQL减少通信次数降低接入成本，例如客户端使用长连接/连接池,NIO等2.2 方案串型io–单线程批量获取问题：node 多，速度慢并行io–多线程批量获取问题：编程复杂，出问题，定位困难hash_tag–让key集中在一台机器上问题：业务维护成本高，可能导致数据倾斜3. 缓存雪崩现象解释：缓存层存在故障，导致所有请求直接请求数据存储层，从而导致存储层调用暴增，造成存储层也会级联宕机。3.1 优化思路（预防和解决）保证缓存层高可用后端提供限流并降级实现提前演练（预防+测试）4.热点key重建现象解释：当前key是一个热点key，并发量非常大；同时，重建缓存不能在短时间内完成。因此，在缓存失效的瞬间，会有大量的线程开始重建缓存，导致后端负载过大。4.1 优化思路减少重建缓存次数数据尽可能一致较少的潜在风险4.2 优化方案互斥锁只允许一个线程重建缓存 —&gt; redis 中setnx命令永远不过期设置一个逻辑过期时间，和value一起存储，当发现key逻辑过期时间小于当前时间时，异步更新key（通过setnx 分布式锁，获取锁，就去异步更新），会出现数据不一致现象参考资料《Redis 开发与运维》]]></content>
      <categories>
        <category>缓存</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【JVM】- 调整Jvm参数SurvivorRatio思路]]></title>
    <url>%2F2019%2F10%2F12%2F%E3%80%90java%E3%80%91-%E8%B0%83%E6%95%B4jvm%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[关于Jvm的内存模型，网上资料很多，这里就不详细介绍了。今天我首先想要分享的是如何调整eden区和Survivor区的比例，即：-XX:SurvivorRatio。（默认是8，即eden：from：to=8：1：1）我们知道Jvm堆内存大小=年轻代+老年代，而年轻代=Eden+2*Survivor,那么如何设置他们的比例关系比较合理呢？我认为的核心思路：尽可能去减少gc次数。尤其full gc 次数我们知道eden区满的时候，会触发young gc，会对eden区和一块 Survivor-From区的内存进行GC，把gc后的存活的内容（超过一定年龄的升入老年代）放入另一块 Survivor-To 区中。如果To区不够，就直接放入老年代。所以为了减少gc次数（young和full gc），应该让每次young gc的后存活的内容最大限度的放入To区，即最大限度的利用内存空间。那么如何观察呢？我们可以使用命令：jstat -gcutil pid 5000 (5秒打印一次jvm信息（比例）) 观察 每次young gc后的 Survivor 区比例占用情况，如果 Survivor 的区每次都只有20-30%的占用比，那么可以适当的减小 Survivor 的大小 即调大 SurvivorRatio 。]]></content>
  </entry>
  <entry>
    <title><![CDATA[【java】- 定位cpu过高问题代码]]></title>
    <url>%2F2019%2F10%2F12%2F%E3%80%90java%E3%80%91-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[相信大家肯定遇到过java程序cpu一直居高不下的情况，那么我来简单介绍在linux系统下如何定位java进程cpu过高的代码位置。首先，使用命令top,找到cpu过高的pid；接着，使用top -Hp pid 找到对应的线程 tid；我们知道jstack可以查看当前java进程的堆栈状态；由于线程在堆栈信息的使用16进制的。那么，printf &quot;%x&quot; tid 可以获取16进制的 tid16。最后使用 jstack pid |grep -A 10 tid16 ，根据情况调整行数后，就可以看到该线程是执行的代码。]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【K8s】- 揭秘K8s健康检查机制 LivenessProbe和ReadinessProbe]]></title>
    <url>%2F2019%2F10%2F10%2F%E3%80%90K8s%E3%80%91-%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[从接触k8s，到目前已经差不多一年时间了，但是对k8s的健康检查机制一直很模糊，今天对其进行了简单的研究，记录如下：概述k8s的健康机制主要是通过两个探测机制：LivenessProbe和ReadinessProbe。LivenessProbe:用于判断容器是否存活（running状态），来确定是否需要重启容器。ReadinessProbe:用于判断容器是否启动完成（ready状态）,来确定是否可以接受流量（请求）。探测方式k8s是通过探测的方式来判断pod是否正常的，那么k8s支持的探测方式有哪些呢？其主要是以下三种：HTTP GET探针 对容器内的目标ip和端口发送HTTP GET请求。响应状态码是2xx或3xx 表示成功。TCP 套接字探针 尝试建立TCP连接，成功建立则成功。Exec探针，在容器内执行shell命令，根据返回结果判断是否成功。]]></content>
      <categories>
        <category>K8s</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【java】- 排查问题命令]]></title>
    <url>%2F2019%2F10%2F08%2F%E3%80%90java%E6%8E%92%E6%9F%A5%E5%91%BD%E4%BB%A4%E3%80%91%2F</url>
    <content type="text"><![CDATA[获取java程序的pid1jps -v查看占用cpu最高线程1top -Hp pid查看某个线程的堆栈信息123//获取 线程id的十六进制printf &quot;%x\n&quot; 线程id jstack pid |grep &lt;16进制&gt;查看堆内存使用情况1jmap -heap pid查看堆内存中的对象数目，大小1jmap -histo:live pid统计jvm信息-查看gc信息（1000毫秒 4次）1jstat -gc pid 1000 4统计jvm信息-查看gc信息比例（1000毫秒 4次）重要1jstat -gcutil pid 1000 4dump heap 命令1jmap -dump:live,format=b,file=heapLive.hprof pid]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【排序算法】- 冒泡排序]]></title>
    <url>%2F2019%2F09%2F26%2F%E3%80%90%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E3%80%91-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[是一个稳定的排序算法最优时间复杂度O(n)，完全有序；最差时间复杂度O(n^2)-逆序123456789101112131415161718// 冒泡排序，a 表示数组，n 表示数组大小public void bubbleSort(int[] a, int n) &#123; if (n &lt;= 1) return; for (int i = 0; i &lt; n; ++i) &#123; // 提前退出冒泡循环的标志位 boolean flag = false; for (int j = 0; j &lt; n - i - 1; ++j) &#123; if (a[j] &gt; a[j+1]) &#123; // 交换 int tmp = a[j]; a[j] = a[j+1]; a[j+1] = tmp; flag = true; // 表示有数据交换 &#125; &#125; if (!flag) break; // 没有数据交换，提前退出 &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【mac操作】- 制作系统盘以及恢复]]></title>
    <url>%2F2019%2F09%2F25%2F%E3%80%90mac%E6%93%8D%E4%BD%9C%E3%80%91-%E5%88%B6%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%98%E4%BB%A5%E5%8F%8A%E6%81%A2%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[一、制作系统操作盘下载操作系统镜像iso查看u盘 diskutil list , /dev/disk2是u盘12345678910111213141516171819~ » diskutil list /dev/disk0 (internal): #: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme 251.0 GB disk0 1: EFI EFI 314.6 MB disk0s1 2: Apple_APFS Container disk1 250.7 GB disk0s2/dev/disk1 (synthesized): #: TYPE NAME SIZE IDENTIFIER 0: APFS Container Scheme - +250.7 GB disk1 Physical Store disk0s2 1: APFS Volume Macintosh HD 125.8 GB disk1s1 2: APFS Volume Preboot 44.4 MB disk1s2 3: APFS Volume Recovery 509.7 MB disk1s3 4: APFS Volume VM 9.7 GB disk1s4/dev/disk2 (external, physical): #: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme *15.9 GB disk2 1: EFI EFI 209.7 MB disk2s1 2: Microsoft Basic Data StarkyDisk 15.7 GB disk2s2解除u盘的挂载状态diskutil unmountDisk /dev/disk2写入u盘sudo dd if=iso镜像路径 of=/dev/rdisk2 bs=1m rdisk二、恢复u盘diskutil eraseDisk ExFAT myDisk /dev/disk2]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【线上问题】- 记一次线上问题的解决方案]]></title>
    <url>%2F2019%2F09%2F25%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[未解决之前存在问题老的java服务，源代码已经找不到了客户需要的接口返回参数里 加了密，加密方式为AES由于该秘钥在其他很多服务中都使用着，不能直接提供给客户使用新的服务，还没有经过测试，无法直接上线，就算能获得测试资源，上线的时间也不能满足客户的需求最终解决方案增加一个代理服务，去调用老的服务，把返回参数解密后返回给客户优点：客户只需要换一下调用的服务端口即可上线非常快（半个小时开发时间）无需关心老的接口]]></content>
      <categories>
        <category>线上问题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【Java】- 获取当天剩余秒数]]></title>
    <url>%2F2019%2F09%2F23%2Fjava%E2%80%94%E8%8E%B7%E5%8F%96%E5%BD%93%E5%A4%A9%E5%89%A9%E4%BD%99%E7%A7%92%E6%95%B0%2F</url>
    <content type="text"><![CDATA[获取当天剩余秒数两种方法1.线程不安全12345678910public static Integer getLeftTime() &#123; Calendar midnight=Calendar.getInstance(); midnight.setTime(new Date()); midnight.add(Calendar.DAY_OF_MONTH,1);//加一天 midnight.set(Calendar.HOUR_OF_DAY,0); midnight.set(Calendar.MINUTE,0); midnight.set(Calendar.SECOND,0); midnight.set(Calendar.MILLISECOND,0); return (int)((midnight.getTime().getTime()-currentDate.getTime())/1000); &#125;2.线程安全123456789 Date now = new Date(); LocalDateTime midnight = LocalDateTime.ofInstant(now.toInstant(), ZoneId.systemDefault()).plusDays(1) .withHour(0) .withMinute(0) .withSecond(0) .withNano(0); LocalDateTime current = LocalDateTime.ofInstant(now.toInstant(), ZoneId.systemDefault()); return (int) ChronoUnit.SECONDS.between(current, midnight);&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Date</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Java8】- Predicate用法]]></title>
    <url>%2F2019%2F09%2F19%2FJava8%E2%80%94Predicate%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[每次失眠，都要庆幸多了一次，可以深刻思考的机会！废话说完,直接上代码：筛选以字母c结尾的字符串1Predicate&lt;String&gt; condition2 = s -&gt; s.endsWith(&quot;c&quot;);筛选以字母a开头的字符串12345Predicate&lt;String&gt; condition1 = s -&gt; s.startsWith(&quot;a&quot;);boolean res1 = condition1.test(&quot;abc&quot;); //true//negate 取反的意思boolean res2 = condition1.negate().test(&quot;abc&quot;) //false筛选以字母a开头 且 以字母c结尾的字符串1Predicate&lt;String&gt; and = condition.and(condition2);筛选以字母a开头 或 以字母c结尾的字符串1Predicate&lt;String&gt; and = condition.or(condition2);筛选大于3的数字1Predicate&lt;Integer&gt; condition2 = a -&gt; a &gt;=3;遍历集合删除以a开头的字符串1List&lt;String&gt; res4 = list.stream().filter(condition1.negate()).collect(Collectors.toList(););]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Predicate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Lamada】- 遍历过滤]]></title>
    <url>%2F2019%2F09%2F19%2FLamada%E2%80%94%E9%81%8D%E5%8E%86%E8%BF%87%E6%BB%A4%2F</url>
    <content type="text"><![CDATA[java8以前，想对list集合进行过滤12345678910111213141516171819202122//不要用Arrays.asList,迭代器删除会失败List&lt;String&gt; list = new ArrayList&lt;&gt;(3);list.add(&quot;abc&quot;);list.add(&quot;bbc&quot;);list.add(&quot;cbc&quot;);//过滤以字母 a 开头的字符串List&lt;String&gt; res = new ArrayList&lt;&gt;();for (String s : list) &#123; if (!s.startsWith(&quot;a&quot;)) &#123; res.add(s); &#125;&#125;//或者这样Iterator&lt;String&gt; it = list.iterator();while (it.hasNext()) &#123; String next = it.next(); if (next.startsWith(&quot;a&quot;)) &#123; it.remove(); &#125;&#125;java8使用lamada实现如下：1List&lt;String&gt; res = list.stream().filter(s -&gt; !s.startsWith(&quot;a&quot;)).collect(Collectors.toList());]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Lamada</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Lamada】- 实现runnable]]></title>
    <url>%2F2019%2F09%2F19%2FLamada%E2%80%94%E5%AE%9E%E7%8E%B0runnable%2F</url>
    <content type="text"><![CDATA[在 Java8 之前开一个新的线程执行任务,具体代码实现如下：1234567//java8 之前new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;开一个新的线程，执行任务了&quot;); &#125; &#125;).start();而java8 提供了lamada表达式，我们可以这样实现：1new Thread(() -&gt; System.out.println(&quot;开一个新的线程，执行任务了&quot;)).start();怎么样，这样的匿名内部实现是不是非常的简单呢！补充：Calculate 是一个接口，里面有一个接口方法cal。如果你想实现该接口，但又不想建一个新的类，可以写成如下这样：12Calculate calculate = (int a, int b) -&gt; a + b;calculate.cal(1,2);]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Lamada</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【k8s】- 常用命令]]></title>
    <url>%2F2019%2F09%2F17%2FK8S-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[一、POD级别的操作获取kube-system命名空间下的所有pod(详细)1kubectl get po -nkube-system（-o wide）获取kube-system命名空间下名为app1的pod的信息1kubectl describe po app1 -nkube-system删除kube-system命名空间下名为app1的pod1kubectl delete po app1 -nkube-system获取kube-system命名空间下名为app1的pod的日志信息1kubectl logs app1 -nkube-system二、Deploy级别的操作获取kube-system命名空间下的所有deploy(详细)1kubectl get deploy -n kube-system（-o wide）编辑kube-system命名空间下的名为deployA 的deploy1kubectl edit deploy deployA -n kube-system更新kube-system命名空间下名为deployA里容器app1的镜像1kubectl set image deploy deployA app1=nginx:1.9.1修改kube-system命名空间下名为deployA里容器app1的资源限制1kubectl set resources deploy deployA -c=app1 --limits=cpu=200m,memory=512Mi修改kube-system命名空间下名为deployA所有容器的资源限制1kubectl set resources deploy deployA· --limits=cpu=200m,memory=512Mi]]></content>
      <categories>
        <category>K8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Lamada】- List转Map]]></title>
    <url>%2F2019%2F09%2F17%2FLamada-List-Map%2F</url>
    <content type="text"><![CDATA[List to Map 一般可以分为以下几种情况:分组去重User.java1234567891011121314151617181920212223242526272829303132333435363738394041import lombok.AllArgsConstructor;import lombok.Data;import java.util.ArrayList;import java.util.List;import java.util.Map;import java.util.function.Function;import java.util.stream.Collectors;@Data@AllArgsConstructorpublic class User &#123; private String name; private Integer age; private Integer grade; private String sex; public static void main(String[] args) &#123; List&lt;User&gt; users =new ArrayList&lt;&gt;(); users.add(new User(&quot;zhangsan&quot;,18,90,&quot;男&quot;)); users.add(new User(&quot;zhangsan&quot;,19,90,&quot;男&quot;)); users.add(new User(&quot;lisi&quot;,19,91,&quot;女&quot;)); //list to map //1.分组，按照姓名分组 Map&lt;String, List&lt;User&gt;&gt; listMap = users.stream().collect( Collectors.groupingBy(User::getName)); //2.分组统计 男女 Map&lt;String, Long&gt; collect = users.stream().collect( Collectors.groupingBy(User::getSex, Collectors.counting()) ); //3.去重，根据年纪，后面的替换前面的，不加会跑出异常 Map&lt;Integer, User&gt; userMap = users.stream().collect( Collectors.toMap( User::getAge, Function.identity(), (oldUser, newUser) -&gt; newUser)); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Lamada</tag>
      </tags>
  </entry>
</search>
