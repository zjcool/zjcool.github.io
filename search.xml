<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[kubernetes学习笔记-17]]></title>
    <url>%2F2018%2F12%2F10%2Fkubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-17%2F</url>
    <content type="text"><![CDATA[今天一天过得不错吧？梦想是不是更远了？ 今天想跟大家分享的K8s中基于Deployment的实现水平扩展/收缩以及滚动更新。 水平扩展/收缩 水平扩展是只要增加服务器数量，就能线性扩充系统性能。在K8s中，Deployment是控制器模式的一个完整实现，其实现了一个重要的功能：水平扩展/收缩（horizontal scaling out/in）。 同时，k8s中，实现滚动更新的API对象称作：ReplicaSet。它的定义是Deployment的一个子集，更重要的是，Deployment控制器实际操纵的，是ReplicaSet对象，而不是Pod对象。同时我们需要明白，一个Deployment所管理的Pod，它的ownerReference是ReplicaSet。 下面我们来看一个Deployment： 123456789101112131415161718192021 apiVersion: apps/v1kind: Deploymentmetadata: name: nginx-deployment labels: app: nginxspec: replicas: 3 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.7.9 ports: - containerPort: 80 可以看出，这里启动是3个版本为1.79的Nginx服务，那么在具体实现上，这个Deployment与ReplicaSet，以及Pod的关系如下图所示：通过这张图，我们可以很清楚的看到，一个replicas=3的Deployment与它的ReplicaSet以及Pod的关系，实际上是一种层层控制的关系。 其中ReplicaSet负责通过“控制器模式”，保证系统中Pod的个数永远等于设置个数。这也正是Deployment只允许容器的restartPolicy=Always的主要原因：只有在容器能保证是 Running 状态的前提下，ReplicaSet调整Pod的个数才有意义。 所以只要将replicas值改动就可以实现水平扩展/收缩 滚动更新 还是以上面的那个Deployment为例: 1 kubectl create -f nginx-deployment.yaml --record --reord 是记录下你每次操作所执行的命令，以方便后面查看。同时，你可以通过 kubectl edit 修改etcd里的api对象（它是把API对象的内容下载到本地文件，修改完后，可以提交上去），kubectl edit 修改完成后，Kubernetes 就会立即触发 滚动更新。 滚动更新过程：首先会根据新的Pod的定义，创建一个新的ReplicaSet，这个新的 ReplicaSet 的初始 Pod 数为0，然后 Deployment Controller 开始将这个新的 ReplicaSet 控制的新的 Pod 数加1，将旧的 Pod 数减1，如此交替进行。像这样，将一个集群中正在运行的多个Pod版本，交替地逐一升级的过程，就是滚动更新。 举个例子来说明滚动更新的好处：在刚升级的时候，集群中只有1个新版本的Pod，如果新版本的Pod有问题，无法启动，那么滚动更新就会停止，从而允许开发和运维介入，而在这个过程中旧Pod依然存在，服务不会受到影响。（当然这里要求你会使用Pod的Health Check机制来检查应用的运行状态，而不是简单的依赖容器的running状态）。 为了进一步保证服务的连续性，Deployment Controller还会确保，在任何时间窗口，只有一定比例的Pod处于离线状态，一定比例的新Pod被创建出来。这个比例是可以配的，默认是DESIRED的值 25%。这个策略是Deployment对象的一个字段，名为 RollingUpdateStrategy 。 综上，我们可以扩展一下Depolyment，ReplicaSet和Pod的关系图了。如上所示：Deployment的控制器，实际上控制的是ReplicaSet的数目，以及每个ReplicaSet的属性。 而一个应用的版本，对应的正是一个ReplicaSet，这个版本应用的Pod数量，则由ReplicaSet通过它自己的控制器（ReplicaSet Controller）来保证。 版本控制基本原理 未完待续。。。 以上就是今天的全部分享。。。。]]></content>
      <categories>
        <category>Kubernetes</category>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>K8s</tag>
        <tag>Deployment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[prometheus学习]]></title>
    <url>%2F2018%2F12%2F07%2Fprometheus%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[人的一切痛苦，本质上都是对自己无能的愤怒。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>prometheus</tag>
      </tags>
  </entry>
</search>
