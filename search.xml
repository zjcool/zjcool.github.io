<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【K8s】- 揭秘K8s健康检查机制 LivenessProbe和ReadinessProbe]]></title>
    <url>%2F2019%2F10%2F10%2F%E3%80%90K8s%E3%80%91-%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[从接触k8s，到目前已经差不多一年时间了，但是对k8s的健康检查机制一直很模糊，今天对其进行了一番研究，记录如下：概述k8s的健康机制主要是通过两个探测机制：LivenessProbe和ReadinessProbe。LivenessProbe:用于判断容器是否存活（running状态），来确定是否需要重启容器。ReadinessProbe:用于判断容器是否启动完成（ready状态）,来确定是否可以接受流量（请求）。探测方式k8s是通过探测的方式来判断pod是否正常的，那么k8s支持的探测方式有哪些呢？其主要是以下三种：HTTP GET探针 对容器内的目标ip和端口发送HTTP GET请求。响应状态码是2xx或3xx 表示成功。TCP 套接字探针 尝试建立TCP连接，成功建立则成功。Exec探针，在容器内执行shell命令，根据返回结果判断是否成功]]></content>
      <categories>
        <category>K8s</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【java】- 排查问题命令]]></title>
    <url>%2F2019%2F10%2F08%2F%E3%80%90java%E6%8E%92%E6%9F%A5%E5%91%BD%E4%BB%A4%E3%80%91%2F</url>
    <content type="text"><![CDATA[获取java程序的pid1jps -v查看占用cpu最高线程1top -Hp pid查看某个线程的堆栈信息123//获取 线程id的十六进制printf &quot;%x\n&quot; 线程id jstack pid |grep &lt;16进制&gt;查看堆内存使用情况1jmap -heap pid查看堆内存中的对象数目，大小1jmap -histo:live pid统计jvm信息-查看gc信息（1000毫秒 4次）1jstat -gc pic 1000 4]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【排序算法】- 冒泡排序]]></title>
    <url>%2F2019%2F09%2F26%2F%E3%80%90%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E3%80%91-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[是一个稳定的排序算法最优时间复杂度O(n)，完全有序；最差时间复杂度O(n^2)-逆序123456789101112131415161718// 冒泡排序，a 表示数组，n 表示数组大小public void bubbleSort(int[] a, int n) &#123; if (n &lt;= 1) return; for (int i = 0; i &lt; n; ++i) &#123; // 提前退出冒泡循环的标志位 boolean flag = false; for (int j = 0; j &lt; n - i - 1; ++j) &#123; if (a[j] &gt; a[j+1]) &#123; // 交换 int tmp = a[j]; a[j] = a[j+1]; a[j+1] = tmp; flag = true; // 表示有数据交换 &#125; &#125; if (!flag) break; // 没有数据交换，提前退出 &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【mac操作】- 制作系统盘以及恢复]]></title>
    <url>%2F2019%2F09%2F25%2F%E3%80%90mac%E6%93%8D%E4%BD%9C%E3%80%91-%E5%88%B6%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%98%E4%BB%A5%E5%8F%8A%E6%81%A2%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[一、制作系统操作盘下载操作系统镜像iso查看u盘 diskutil list , /dev/disk2是u盘12345678910111213141516171819~ » diskutil list /dev/disk0 (internal): #: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme 251.0 GB disk0 1: EFI EFI 314.6 MB disk0s1 2: Apple_APFS Container disk1 250.7 GB disk0s2/dev/disk1 (synthesized): #: TYPE NAME SIZE IDENTIFIER 0: APFS Container Scheme - +250.7 GB disk1 Physical Store disk0s2 1: APFS Volume Macintosh HD 125.8 GB disk1s1 2: APFS Volume Preboot 44.4 MB disk1s2 3: APFS Volume Recovery 509.7 MB disk1s3 4: APFS Volume VM 9.7 GB disk1s4/dev/disk2 (external, physical): #: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme *15.9 GB disk2 1: EFI EFI 209.7 MB disk2s1 2: Microsoft Basic Data StarkyDisk 15.7 GB disk2s2解除u盘的挂载状态diskutil unmountDisk /dev/disk2写入u盘sudo dd if=iso镜像路径 of=/dev/rdisk2 bs=1m rdisk二、恢复u盘diskutil eraseDisk ExFAT myDisk /dev/disk2]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【线上问题】- 记一次线上问题的解决方案]]></title>
    <url>%2F2019%2F09%2F25%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[未解决之前存在问题老的java服务，源代码已经找不到了客户需要的接口返回参数里 加了密，加密方式为AES由于该秘钥在其他很多服务中都使用着，不能直接提供给客户使用新的服务，还没有经过测试，无法直接上线，就算能获得测试资源，上线的时间也不能满足客户的需求最终解决方案增加一个代理服务，去调用老的服务，把返回参数解密后返回给客户优点：客户只需要换一下调用的服务端口即可上线非常快（半个小时开发时间）无需关心老的接口]]></content>
      <categories>
        <category>线上问题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【Java】- 获取当天剩余秒数]]></title>
    <url>%2F2019%2F09%2F23%2Fjava%E2%80%94%E8%8E%B7%E5%8F%96%E5%BD%93%E5%A4%A9%E5%89%A9%E4%BD%99%E7%A7%92%E6%95%B0%2F</url>
    <content type="text"><![CDATA[获取当天剩余秒数两种方法1.线程不安全12345678910public static Integer getLeftTime() &#123; Calendar midnight=Calendar.getInstance(); midnight.setTime(new Date()); midnight.add(Calendar.DAY_OF_MONTH,1);//加一天 midnight.set(Calendar.HOUR_OF_DAY,0); midnight.set(Calendar.MINUTE,0); midnight.set(Calendar.SECOND,0); midnight.set(Calendar.MILLISECOND,0); return (int)((midnight.getTime().getTime()-currentDate.getTime())/1000); &#125;2.线程安全12345678910 Date now = new Date(); LocalDateTime midnight = LocalDateTime.ofInstant(now.toInstant(), ZoneId.systemDefault()); midnight.plusDays(1) .withHour(0) .withMinute(0) .withSecond(0) .withNano(0); LocalDateTime current = LocalDateTime.ofInstant(now.toInstant(), ZoneId.systemDefault()); return (int) ChronoUnit.SECONDS.between(current, midnight);&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Date</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Java8】- Predicate用法]]></title>
    <url>%2F2019%2F09%2F19%2FJava8%E2%80%94Predicate%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[每次失眠，都要庆幸多了一次，可以深刻思考的机会！废话说完,直接上代码：筛选以字母c结尾的字符串1Predicate&lt;String&gt; condition2 = s -&gt; s.endsWith(&quot;c&quot;);筛选以字母a开头的字符串12345Predicate&lt;String&gt; condition1 = s -&gt; s.startsWith(&quot;a&quot;);boolean res1 = condition1.test(&quot;abc&quot;); //true//negate 取反的意思boolean res2 = condition1.negate().test(&quot;abc&quot;) //false筛选以字母a开头 且 以字母c结尾的字符串1Predicate&lt;String&gt; and = condition.and(condition2);筛选以字母a开头 或 以字母c结尾的字符串1Predicate&lt;String&gt; and = condition.or(condition2);筛选大于3的数字1Predicate&lt;Integer&gt; condition2 = a -&gt; a &gt;=3;遍历集合删除以a开头的字符串1List&lt;String&gt; res4 = list.stream().filter(condition1.negate()).collect(Collectors.toList(););]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Predicate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Lamada】- 遍历过滤]]></title>
    <url>%2F2019%2F09%2F19%2FLamada%E2%80%94%E9%81%8D%E5%8E%86%E8%BF%87%E6%BB%A4%2F</url>
    <content type="text"><![CDATA[java8以前，想对list集合进行过滤12345678910111213141516171819202122//不要用Arrays.asList,迭代器删除会失败List&lt;String&gt; list = new ArrayList&lt;&gt;(3);list.add(&quot;abc&quot;);list.add(&quot;bbc&quot;);list.add(&quot;cbc&quot;);//过滤以字母 a 开头的字符串List&lt;String&gt; res = new ArrayList&lt;&gt;();for (String s : list) &#123; if (!s.startsWith(&quot;a&quot;)) &#123; res.add(s); &#125;&#125;//或者这样Iterator&lt;String&gt; it = list.iterator();while (it.hasNext()) &#123; String next = it.next(); if (next.startsWith(&quot;a&quot;)) &#123; it.remove(); &#125;&#125;java8使用lamada实现如下：1List&lt;String&gt; res = list.stream().filter(s -&gt; !s.startsWith(&quot;a&quot;)).collect(Collectors.toList());]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Lamada</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Lamada】- 实现runnable]]></title>
    <url>%2F2019%2F09%2F19%2FLamada%E2%80%94%E5%AE%9E%E7%8E%B0runnable%2F</url>
    <content type="text"><![CDATA[在 Java8 之前开一个新的线程执行任务,具体代码实现如下：1234567//java8 之前new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;开一个新的线程，执行任务了&quot;); &#125; &#125;).start();而java8 提供了lamada表达式，我们可以这样实现：1new Thread(() -&gt; System.out.println(&quot;开一个新的线程，执行任务了&quot;)).start();怎么样，这样的匿名内部实现是不是非常的简单呢！补充：Calculate 是一个接口，里面有一个接口方法cal。如果你想实现该接口，但又不想建一个新的类，可以写成如下这样：12Calculate calculate = (int a, int b) -&gt; a + b;calculate.cal(1,2);]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Lamada</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【k8s】- 常用命令]]></title>
    <url>%2F2019%2F09%2F17%2FK8S-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[一、POD级别的操作获取kube-system命名空间下的所有pod(详细)1kubectl get po -nkube-system（-o wide）获取kube-system命名空间下名为app1的pod的信息1kubectl describe po app1 -nkube-system删除kube-system命名空间下名为app1的pod1kubectl delete po app1 -nkube-system获取kube-system命名空间下名为app1的pod的日志信息1kubectl logs app1 -nkube-system二、Deploy级别的操作获取kube-system命名空间下的所有deploy(详细)1kubectl get deploy -n kube-system（-o wide）编辑kube-system命名空间下的名为deployA 的deploy1kubectl edit deploy deployA -n kube-system更新kube-system命名空间下名为deployA里容器app1的镜像1kubectl set image deploy deployA app1=nginx:1.9.1修改kube-system命名空间下名为deployA里容器app1的资源限制1kubectl set resources deploy deployA -c=app1 --limits=cpu=200m,memory=512Mi修改kube-system命名空间下名为deployA所有容器的资源限制1kubectl set resources deploy deployA· --limits=cpu=200m,memory=512Mi]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Lamada】- List转Map]]></title>
    <url>%2F2019%2F09%2F17%2FLamada-List-Map%2F</url>
    <content type="text"><![CDATA[List to Map 一般可以分为以下几种情况:分组去重User.java1234567891011121314151617181920212223242526272829303132333435363738394041import lombok.AllArgsConstructor;import lombok.Data;import java.util.ArrayList;import java.util.List;import java.util.Map;import java.util.function.Function;import java.util.stream.Collectors;@Data@AllArgsConstructorpublic class User &#123; private String name; private Integer age; private Integer grade; private String sex; public static void main(String[] args) &#123; List&lt;User&gt; users =new ArrayList&lt;&gt;(); users.add(new User(&quot;zhangsan&quot;,18,90,&quot;男&quot;)); users.add(new User(&quot;zhangsan&quot;,19,90,&quot;男&quot;)); users.add(new User(&quot;lisi&quot;,19,91,&quot;女&quot;)); //list to map //1.分组，按照姓名分组 Map&lt;String, List&lt;User&gt;&gt; listMap = users.stream().collect( Collectors.groupingBy(User::getName)); //2.分组统计 男女 Map&lt;String, Long&gt; collect = users.stream().collect( Collectors.groupingBy(User::getSex, Collectors.counting()) ); //3.去重，根据年纪，后面的替换前面的，不加会跑出异常 Map&lt;Integer, User&gt; userMap = users.stream().collect( Collectors.toMap( User::getAge, Function.identity(), (oldUser, newUser) -&gt; newUser)); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Lamada</tag>
      </tags>
  </entry>
</search>
