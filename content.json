{"meta":{"title":"回归初心，轻装前行","subtitle":null,"description":null,"author":"zhangj","url":"https://zjcool.github.io","root":"/"},"pages":[{"title":"关于自己","date":"2019-09-07T03:07:32.000Z","updated":"2019-09-19T13:00:34.472Z","comments":false,"path":"about/index.html","permalink":"https://zjcool.github.io/about/index.html","excerpt":"","text":"回头补充"},{"title":"友情链接","date":"2019-09-23T15:30:47.000Z","updated":"2019-09-23T15:30:47.094Z","comments":true,"path":"links/index.html","permalink":"https://zjcool.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-09-18T18:10:41.000Z","updated":"2019-09-18T18:11:06.825Z","comments":false,"path":"tags/index.html","permalink":"https://zjcool.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-09-18T18:07:01.000Z","updated":"2019-09-18T18:09:28.869Z","comments":false,"path":"categories/index.html","permalink":"https://zjcool.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"【springboot源码解析】-- 解读过程一","slug":"【springboot源码解析】-SpringApplication","date":"2019-11-19T08:05:01.000Z","updated":"2019-11-19T12:12:46.958Z","comments":true,"path":"2019/11/19/【springboot源码解析】-SpringApplication/","link":"","permalink":"https://zjcool.github.io/2019/11/19/【springboot源码解析】-SpringApplication/","excerpt":"","text":"概述从工作开始接触 springboot 到现在将近过去两年时光了，虽偶然看看springboot启动源码，但从未仔细研读深究过，网上虽然有很多源码解析，但是每次读几篇就会因为各种原因半途而止，这次准备花一点时间好好将底层源码研究一番。好了，废话就不多说了，我们正式开始 springboot 之旅吧!请看下面代码吧：12345678@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125;想必大家对上面的代码都不会陌生，任何一个 springboot 服务都是由此方法开始启动的，开始一个个来解释。@SpringBootApplication 注解官方给出的解释是This is a convenience annotation that is equivalent to declaring {@code @Configuration}, {@code @EnableAutoConfiguration} and {@code @ComponentScan}.也就是说 @SpringBootApplication 是 @Configuration、@EnableAutoConfiguration、@ComponentScan 三个注解的组合注解。想详细了解这三个注解的含义，可以阅读以下文章：深入理解 – @Configuration 注解深入理解 – @EnableAutoConfiguration 注解深入理解 – @ComponentScan 注解主函数主函数依次执行step 1：1SpringApplication.run(Application.class, args);step 2：1234public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) &#123; return new SpringApplication(primarySources).run(args); &#125;primarySources 就是 Application.classstep 3：开始执行的 SpringApplication 的构造方法1234567891011121314public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123; this.resourceLoader = resourceLoader; Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;); this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources)); //&lt;1&gt; 从classPath中推测当前应用是什么类型的应用， this.webApplicationType = WebApplicationType.deduceFromClasspath(); //&lt;2&gt; 设置 spring 容器的初始化器（ApplicationContextInitializer） setInitializers((Collection) getSpringFactoriesInstances( ApplicationContextInitializer.class)); // &lt;3&gt;设置 spring 容器的监听器 setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); // 设置主类，即 Application.class this.mainApplicationClass = deduceMainApplicationClass(); &#125;&lt;1&gt; WebApplicationType类型包括 SERVLET、REACTIVE、NONE，后面会根据不同的类型，以不同的方式来启动服务&lt;2&gt;会从 spring-boot 和 spring-boot-autoconfigure 的jar包里的META-INF/spring.factories 中加载所有的 ApplicationContextInitializer 作为 spring 容器的初始化器 ApplicationContextInitializer&lt;3&gt; 会从 spring-boot 和spring-boot-autoconfigure 的jar包里的META-INF/spring.factories 中加载所有的 Listenerstep 4： 开始运行Spring 应用，刷新上下文这一步内容有点多，请耐心查看12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//SpringApptionlication.java// springboot 启动过程public ConfigurableApplicationContext run(String... args) &#123; // stopWatch 是一个计算代码时间的类 StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; //异常收集容器 Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;(); // 开启无设备鼠标键盘模式（需要提供一些（设备）信息给客户端） configureHeadlessProperty(); // 反射生成 SpringApplicationRunListener 的实现类----&gt; EventPublishingRunListener 即获取Spring启动监听器 SpringApplicationRunListeners listeners = getRunListeners(args); // 触发 ApplicationStartingEvent 事件，执行对应动作 listeners.starting(); try &#123; // 获取环境配置 ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); // &lt;1&gt;生成环境配置+设置环境变量 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); // 忽略的配置的 bean configureIgnoreBeanInfo(environment); //输出banner Banner printedBanner = printBanner(environment); //生成应用上下文（这里会生成基于注解的 AnnotationConfigServletWebServerApplicationContext） context = createApplicationContext(); // 反射生产一些异常收集器 exceptionReporters = getSpringFactoriesInstances( SpringBootExceptionReporter.class, new Class[] &#123; ConfigurableApplicationContext.class &#125;, context); //准备上下文，会触发准备上下文事件 prepareContext(context, environment, listeners, applicationArguments, printedBanner); //刷新上下文 refreshContext(context); afterRefresh(context, applicationArguments); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; listeners.started(context); callRunners(context, applicationArguments); &#125; catch (Throwable ex) &#123; handleRunFailure(context, ex, exceptionReporters, listeners); throw new IllegalStateException(ex); &#125; try &#123; listeners.running(context); &#125; catch (Throwable ex) &#123; handleRunFailure(context, ex, exceptionReporters, null); throw new IllegalStateException(ex); &#125; return context; &#125;&lt;1&gt;","categories":[],"tags":[],"author":"zhangj"},{"title":"【redis命令介绍】-  client list","slug":"【redis命令介绍】-client","date":"2019-10-22T12:21:00.000Z","updated":"2019-10-22T12:37:08.257Z","comments":true,"path":"2019/10/22/【redis命令介绍】-client/","link":"","permalink":"https://zjcool.github.io/2019/10/22/【redis命令介绍】-client/","excerpt":"","text":"client list : 返回所有连接到服务器的客户端信息和统计数据返回值的含义： * id: 唯一的64位的客户端ID(Redis 2.8.12加入)。 * addr: 客户端的地址和端口 * fd: 套接字所使用的文件描述符 * age: 以秒计算的已连接时长 * idle: 以秒计算的空闲时长 * flags: 客户端 flag * db: 该客户端正在使用的数据库 ID * sub: 已订阅频道的数量 * psub: 已订阅模式的数量 * multi: 在事务中被执行的命令数量 * qbuf: 查询缓冲区的长度（字节为单位， 0 表示没有分配查询缓冲区） * qbuf-free: 查询缓冲区剩余空间的长度（字节为单位， 0 表示没有剩余空间） * obl: 输出缓冲区的长度（字节为单位， 0 表示没有分配输出缓冲区） * oll: 输出列表包含的对象数量（当输出缓冲区没有剩余空间时，命令回复会以字符串对象的形式被入队到这个队列里） * omem: 输出缓冲区和输出列表占用的内存总量 * events: 文件描述符事件 * cmd: 最近一次执行的命令","categories":[{"name":"redis","slug":"redis","permalink":"https://zjcool.github.io/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://zjcool.github.io/tags/redis/"}],"author":"zhangj"},{"title":"缓存问题及优化方案总结","slug":"redis缓存","date":"2019-10-22T10:05:00.000Z","updated":"2019-10-22T12:30:56.759Z","comments":true,"path":"2019/10/22/redis缓存/","link":"","permalink":"https://zjcool.github.io/2019/10/22/redis缓存/","excerpt":"","text":"缓存优化1. 缓存穿透现象解释：大量出现查询一个根本不存在的数据，缓存层和存储层都不会命中。从而导致后端负载加大，甚至服务宕机。1.1 穿透优化方案缓存空对象+设置过期时间缓存层之前加一个布隆过滤器（判断一定不存在，就不到缓存层去找了）适用场景：数据命中不高、数据相对稳定、实时性低（通常数据集较大）的应用场景。1.2 对比方案适用场景维护成本缓存空对象数据命中不高、数据频繁变化代码维护简单、需要更多缓存空间、数据源不一致布隆过滤器数据命中不高、数据相对固定、实时性低代码维护复杂、缓存空间占用少2. 无底洞现象解释：水平增加节点，性能不升，反而可能出现下降的情况。可能原因分析：一次批量操作会涉及多次网络操作，随着节点增加，耗时增大网络连接数变多，对节点性能存在一定的影响2.1 无底洞优化思路命令本身的优化，例如优化SQL减少通信次数降低接入成本，例如客户端使用长连接/连接池,NIO等2.2 方案串型io–单线程批量获取问题：node 多，速度慢并行io–多线程批量获取问题：编程复杂，出问题，定位困难hash_tag–让key集中在一台机器上问题：业务维护成本高，可能导致数据倾斜3. 缓存雪崩现象解释：缓存层存在故障，导致所有请求直接请求数据存储层，从而导致存储层调用暴增，造成存储层也会级联宕机。3.1 优化思路（预防和解决）保证缓存层高可用后端提供限流并降级实现提前演练（预防+测试）4.热点key重建现象解释：当前key是一个热点key，并发量非常大；同时，重建缓存不能在短时间内完成。因此，在缓存失效的瞬间，会有大量的线程开始重建缓存，导致后端负载过大。4.1 优化思路减少重建缓存次数数据尽可能一致较少的潜在风险4.2 优化方案互斥锁只允许一个线程重建缓存 —&gt; redis 中setnx命令永远不过期设置一个逻辑过期时间，和value一起存储，当发现key逻辑过期时间小于当前时间时，异步更新key（通过setnx 分布式锁，获取锁，就去异步更新），会出现数据不一致现象参考资料《Redis 开发与运维》","categories":[{"name":"缓存","slug":"缓存","permalink":"https://zjcool.github.io/categories/缓存/"}],"tags":[],"author":"zhangj"},{"title":"【JVM】- 调整Jvm参数SurvivorRatio思路","slug":"【java】-调整jvm思路","date":"2019-10-12T03:17:39.000Z","updated":"2019-10-12T04:07:45.781Z","comments":true,"path":"2019/10/12/【java】-调整jvm思路/","link":"","permalink":"https://zjcool.github.io/2019/10/12/【java】-调整jvm思路/","excerpt":"","text":"关于Jvm的内存模型，网上资料很多，这里就不详细介绍了。今天我首先想要分享的是如何调整eden区和Survivor区的比例，即：-XX:SurvivorRatio。（默认是8，即eden：from：to=8：1：1）我们知道Jvm堆内存大小=年轻代+老年代，而年轻代=Eden+2*Survivor,那么如何设置他们的比例关系比较合理呢？我认为的核心思路：尽可能去减少gc次数。尤其full gc 次数我们知道eden区满的时候，会触发young gc，会对eden区和一块 Survivor-From区的内存进行GC，把gc后的存活的内容（超过一定年龄的升入老年代）放入另一块 Survivor-To 区中。如果To区不够，就直接放入老年代。所以为了减少gc次数（young和full gc），应该让每次young gc的后存活的内容最大限度的放入To区，即最大限度的利用内存空间。那么如何观察呢？我们可以使用命令：jstat -gcutil pid 5000 (5秒打印一次jvm信息（比例）) 观察 每次young gc后的 Survivor 区比例占用情况，如果 Survivor 的区每次都只有20-30%的占用比，那么可以适当的减小 Survivor 的大小 即调大 SurvivorRatio 。","categories":[],"tags":[],"author":"zhangj"},{"title":"【java】- 定位cpu过高问题代码","slug":"【java】-性能调优步骤","date":"2019-10-12T02:48:00.000Z","updated":"2019-10-12T03:15:33.015Z","comments":true,"path":"2019/10/12/【java】-性能调优步骤/","link":"","permalink":"https://zjcool.github.io/2019/10/12/【java】-性能调优步骤/","excerpt":"","text":"相信大家肯定遇到过java程序cpu一直居高不下的情况，那么我来简单介绍在linux系统下如何定位java进程cpu过高的代码位置。首先，使用命令top,找到cpu过高的pid；接着，使用top -Hp pid 找到对应的线程 tid；我们知道jstack可以查看当前java进程的堆栈状态；由于线程在堆栈信息的使用16进制的。那么，printf &quot;%x&quot; tid 可以获取16进制的 tid16。最后使用 jstack pid |grep -A 10 tid16 ，根据情况调整行数后，就可以看到该线程是执行的代码。","categories":[{"name":"java","slug":"java","permalink":"https://zjcool.github.io/categories/java/"}],"tags":[],"author":"zhangj"},{"title":"【K8s】- 揭秘K8s健康检查机制 LivenessProbe和ReadinessProbe","slug":"【K8s】-健康检查机制","date":"2019-10-10T07:35:00.000Z","updated":"2019-10-10T08:37:43.053Z","comments":true,"path":"2019/10/10/【K8s】-健康检查机制/","link":"","permalink":"https://zjcool.github.io/2019/10/10/【K8s】-健康检查机制/","excerpt":"","text":"从接触k8s，到目前已经差不多一年时间了，但是对k8s的健康检查机制一直很模糊，今天对其进行了简单的研究，记录如下：概述k8s的健康机制主要是通过两个探测机制：LivenessProbe和ReadinessProbe。LivenessProbe:用于判断容器是否存活（running状态），来确定是否需要重启容器。ReadinessProbe:用于判断容器是否启动完成（ready状态）,来确定是否可以接受流量（请求）。探测方式k8s是通过探测的方式来判断pod是否正常的，那么k8s支持的探测方式有哪些呢？其主要是以下三种：HTTP GET探针 对容器内的目标ip和端口发送HTTP GET请求。响应状态码是2xx或3xx 表示成功。TCP 套接字探针 尝试建立TCP连接，成功建立则成功。Exec探针，在容器内执行shell命令，根据返回结果判断是否成功。","categories":[{"name":"K8s","slug":"K8s","permalink":"https://zjcool.github.io/categories/K8s/"}],"tags":[],"author":"zhangj"},{"title":"【java】- 排查问题命令","slug":"【java排查命令】","date":"2019-10-08T08:50:00.000Z","updated":"2019-11-21T08:19:53.096Z","comments":true,"path":"2019/10/08/【java排查命令】/","link":"","permalink":"https://zjcool.github.io/2019/10/08/【java排查命令】/","excerpt":"","text":"获取java程序的pid1jps -v查看占用cpu最高线程1top -Hp pid查看某个线程的堆栈信息123//获取 线程id的十六进制printf &quot;%x\\n&quot; 线程id jstack pid |grep &lt;16进制&gt;查看堆内存使用情况1jmap -heap pid查看堆内存中的对象数目，大小1jmap -histo:live pid统计jvm信息-查看gc信息（1000毫秒 4次）1jstat -gc pid 1000 4统计jvm信息-查看gc信息比例（1000毫秒 4次）重要1jstat -gcutil pid 1000 4dump heap 命令1jmap -dump:live,format=b,file=heapLive.hprof pid","categories":[{"name":"Java","slug":"Java","permalink":"https://zjcool.github.io/categories/Java/"}],"tags":[],"author":"zhangj"},{"title":"【排序算法】-  冒泡排序","slug":"【排序算法】-冒泡排序","date":"2019-09-26T15:11:45.000Z","updated":"2019-10-08T08:49:07.128Z","comments":true,"path":"2019/09/26/【排序算法】-冒泡排序/","link":"","permalink":"https://zjcool.github.io/2019/09/26/【排序算法】-冒泡排序/","excerpt":"","text":"是一个稳定的排序算法最优时间复杂度O(n)，完全有序；最差时间复杂度O(n^2)-逆序123456789101112131415161718// 冒泡排序，a 表示数组，n 表示数组大小public void bubbleSort(int[] a, int n) &#123; if (n &lt;= 1) return; for (int i = 0; i &lt; n; ++i) &#123; // 提前退出冒泡循环的标志位 boolean flag = false; for (int j = 0; j &lt; n - i - 1; ++j) &#123; if (a[j] &gt; a[j+1]) &#123; // 交换 int tmp = a[j]; a[j] = a[j+1]; a[j+1] = tmp; flag = true; // 表示有数据交换 &#125; &#125; if (!flag) break; // 没有数据交换，提前退出 &#125;&#125;","categories":[],"tags":[],"author":"zhangj"},{"title":"【mac操作】-  制作系统盘以及恢复","slug":"【mac操作】-制作系统盘以及恢复","date":"2019-09-25T07:55:00.000Z","updated":"2019-09-25T08:18:08.976Z","comments":true,"path":"2019/09/25/【mac操作】-制作系统盘以及恢复/","link":"","permalink":"https://zjcool.github.io/2019/09/25/【mac操作】-制作系统盘以及恢复/","excerpt":"","text":"一、制作系统操作盘下载操作系统镜像iso查看u盘 diskutil list , /dev/disk2是u盘12345678910111213141516171819~ » diskutil list /dev/disk0 (internal): #: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme 251.0 GB disk0 1: EFI EFI 314.6 MB disk0s1 2: Apple_APFS Container disk1 250.7 GB disk0s2/dev/disk1 (synthesized): #: TYPE NAME SIZE IDENTIFIER 0: APFS Container Scheme - +250.7 GB disk1 Physical Store disk0s2 1: APFS Volume Macintosh HD 125.8 GB disk1s1 2: APFS Volume Preboot 44.4 MB disk1s2 3: APFS Volume Recovery 509.7 MB disk1s3 4: APFS Volume VM 9.7 GB disk1s4/dev/disk2 (external, physical): #: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme *15.9 GB disk2 1: EFI EFI 209.7 MB disk2s1 2: Microsoft Basic Data StarkyDisk 15.7 GB disk2s2解除u盘的挂载状态diskutil unmountDisk /dev/disk2写入u盘sudo dd if=iso镜像路径 of=/dev/rdisk2 bs=1m rdisk二、恢复u盘diskutil eraseDisk ExFAT myDisk /dev/disk2","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://zjcool.github.io/categories/操作系统/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://zjcool.github.io/tags/mac/"}],"author":"zhangj"},{"title":"【线上问题】-  记一次线上问题的解决方案","slug":"记一次线上问题解决方案","date":"2019-09-25T06:38:00.000Z","updated":"2019-09-25T08:26:11.367Z","comments":true,"path":"2019/09/25/记一次线上问题解决方案/","link":"","permalink":"https://zjcool.github.io/2019/09/25/记一次线上问题解决方案/","excerpt":"","text":"未解决之前存在问题老的java服务，源代码已经找不到了客户需要的接口返回参数里 加了密，加密方式为AES由于该秘钥在其他很多服务中都使用着，不能直接提供给客户使用新的服务，还没有经过测试，无法直接上线，就算能获得测试资源，上线的时间也不能满足客户的需求最终解决方案增加一个代理服务，去调用老的服务，把返回参数解密后返回给客户优点：客户只需要换一下调用的服务端口即可上线非常快（半个小时开发时间）无需关心老的接口","categories":[{"name":"线上问题","slug":"线上问题","permalink":"https://zjcool.github.io/categories/线上问题/"}],"tags":[],"author":"zhangj"},{"title":"【Java】-  获取当天剩余秒数","slug":"java—获取当天剩余秒数","date":"2019-09-23T15:11:00.000Z","updated":"2019-10-23T09:22:47.949Z","comments":true,"path":"2019/09/23/java—获取当天剩余秒数/","link":"","permalink":"https://zjcool.github.io/2019/09/23/java—获取当天剩余秒数/","excerpt":"","text":"获取当天剩余秒数两种方法1.线程不安全12345678910public static Integer getLeftTime() &#123; Calendar midnight=Calendar.getInstance(); midnight.setTime(new Date()); midnight.add(Calendar.DAY_OF_MONTH,1);//加一天 midnight.set(Calendar.HOUR_OF_DAY,0); midnight.set(Calendar.MINUTE,0); midnight.set(Calendar.SECOND,0); midnight.set(Calendar.MILLISECOND,0); return (int)((midnight.getTime().getTime()-currentDate.getTime())/1000); &#125;2.线程安全123456789 Date now = new Date(); LocalDateTime midnight = LocalDateTime.ofInstant(now.toInstant(), ZoneId.systemDefault()).plusDays(1) .withHour(0) .withMinute(0) .withSecond(0) .withNano(0); LocalDateTime current = LocalDateTime.ofInstant(now.toInstant(), ZoneId.systemDefault()); return (int) ChronoUnit.SECONDS.between(current, midnight);&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zjcool.github.io/categories/Java/"}],"tags":[{"name":"Date","slug":"Date","permalink":"https://zjcool.github.io/tags/Date/"}],"author":"zhangj"},{"title":"【Java8】-  Predicate用法","slug":"Java8—Predicate用法","date":"2019-09-19T14:58:00.000Z","updated":"2019-09-25T08:27:14.217Z","comments":true,"path":"2019/09/19/Java8—Predicate用法/","link":"","permalink":"https://zjcool.github.io/2019/09/19/Java8—Predicate用法/","excerpt":"","text":"每次失眠，都要庆幸多了一次，可以深刻思考的机会！废话说完,直接上代码：筛选以字母c结尾的字符串1Predicate&lt;String&gt; condition2 = s -&gt; s.endsWith(&quot;c&quot;);筛选以字母a开头的字符串12345Predicate&lt;String&gt; condition1 = s -&gt; s.startsWith(&quot;a&quot;);boolean res1 = condition1.test(&quot;abc&quot;); //true//negate 取反的意思boolean res2 = condition1.negate().test(&quot;abc&quot;) //false筛选以字母a开头 且 以字母c结尾的字符串1Predicate&lt;String&gt; and = condition.and(condition2);筛选以字母a开头 或 以字母c结尾的字符串1Predicate&lt;String&gt; and = condition.or(condition2);筛选大于3的数字1Predicate&lt;Integer&gt; condition2 = a -&gt; a &gt;=3;遍历集合删除以a开头的字符串1List&lt;String&gt; res4 = list.stream().filter(condition1.negate()).collect(Collectors.toList(););","categories":[{"name":"Java","slug":"Java","permalink":"https://zjcool.github.io/categories/Java/"}],"tags":[{"name":"Predicate","slug":"Predicate","permalink":"https://zjcool.github.io/tags/Predicate/"}],"author":"zhangj"},{"title":"【Lamada】-  遍历过滤","slug":"Lamada—遍历过滤","date":"2019-09-19T13:31:00.000Z","updated":"2019-09-25T08:09:20.512Z","comments":true,"path":"2019/09/19/Lamada—遍历过滤/","link":"","permalink":"https://zjcool.github.io/2019/09/19/Lamada—遍历过滤/","excerpt":"","text":"java8以前，想对list集合进行过滤12345678910111213141516171819202122//不要用Arrays.asList,迭代器删除会失败List&lt;String&gt; list = new ArrayList&lt;&gt;(3);list.add(&quot;abc&quot;);list.add(&quot;bbc&quot;);list.add(&quot;cbc&quot;);//过滤以字母 a 开头的字符串List&lt;String&gt; res = new ArrayList&lt;&gt;();for (String s : list) &#123; if (!s.startsWith(&quot;a&quot;)) &#123; res.add(s); &#125;&#125;//或者这样Iterator&lt;String&gt; it = list.iterator();while (it.hasNext()) &#123; String next = it.next(); if (next.startsWith(&quot;a&quot;)) &#123; it.remove(); &#125;&#125;java8使用lamada实现如下：1List&lt;String&gt; res = list.stream().filter(s -&gt; !s.startsWith(&quot;a&quot;)).collect(Collectors.toList());","categories":[{"name":"Java","slug":"Java","permalink":"https://zjcool.github.io/categories/Java/"}],"tags":[{"name":"Lamada","slug":"Lamada","permalink":"https://zjcool.github.io/tags/Lamada/"}],"author":"zhangj"},{"title":"【Lamada】-  实现runnable","slug":"Lamada—实现runnable","date":"2019-09-19T13:05:00.000Z","updated":"2019-09-25T08:09:32.504Z","comments":true,"path":"2019/09/19/Lamada—实现runnable/","link":"","permalink":"https://zjcool.github.io/2019/09/19/Lamada—实现runnable/","excerpt":"","text":"在 Java8 之前开一个新的线程执行任务,具体代码实现如下：1234567//java8 之前new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;开一个新的线程，执行任务了&quot;); &#125; &#125;).start();而java8 提供了lamada表达式，我们可以这样实现：1new Thread(() -&gt; System.out.println(&quot;开一个新的线程，执行任务了&quot;)).start();怎么样，这样的匿名内部实现是不是非常的简单呢！补充：Calculate 是一个接口，里面有一个接口方法cal。如果你想实现该接口，但又不想建一个新的类，可以写成如下这样：12Calculate calculate = (int a, int b) -&gt; a + b;calculate.cal(1,2);","categories":[{"name":"Java","slug":"Java","permalink":"https://zjcool.github.io/categories/Java/"}],"tags":[{"name":"Lamada","slug":"Lamada","permalink":"https://zjcool.github.io/tags/Lamada/"}],"author":"zhangj"},{"title":"【k8s】-  常用命令","slug":"K8S-常用命令","date":"2019-09-17T14:22:00.000Z","updated":"2019-10-10T08:40:21.642Z","comments":true,"path":"2019/09/17/K8S-常用命令/","link":"","permalink":"https://zjcool.github.io/2019/09/17/K8S-常用命令/","excerpt":"","text":"一、POD级别的操作获取kube-system命名空间下的所有pod(详细)1kubectl get po -nkube-system（-o wide）获取kube-system命名空间下名为app1的pod的信息1kubectl describe po app1 -nkube-system删除kube-system命名空间下名为app1的pod1kubectl delete po app1 -nkube-system获取kube-system命名空间下名为app1的pod的日志信息1kubectl logs app1 -nkube-system二、Deploy级别的操作获取kube-system命名空间下的所有deploy(详细)1kubectl get deploy -n kube-system（-o wide）编辑kube-system命名空间下的名为deployA 的deploy1kubectl edit deploy deployA -n kube-system更新kube-system命名空间下名为deployA里容器app1的镜像1kubectl set image deploy deployA app1=nginx:1.9.1修改kube-system命名空间下名为deployA里容器app1的资源限制1kubectl set resources deploy deployA -c=app1 --limits=cpu=200m,memory=512Mi修改kube-system命名空间下名为deployA所有容器的资源限制1kubectl set resources deploy deployA· --limits=cpu=200m,memory=512Mi","categories":[{"name":"K8s","slug":"K8s","permalink":"https://zjcool.github.io/categories/K8s/"}],"tags":[{"name":"k8s","slug":"k8s","permalink":"https://zjcool.github.io/tags/k8s/"},{"name":"kubernetes","slug":"kubernetes","permalink":"https://zjcool.github.io/tags/kubernetes/"}],"author":"zhangj"},{"title":"【Lamada】-  List转Map","slug":"Lamada-List-Map","date":"2019-09-17T12:29:00.000Z","updated":"2019-09-25T08:09:50.659Z","comments":true,"path":"2019/09/17/Lamada-List-Map/","link":"","permalink":"https://zjcool.github.io/2019/09/17/Lamada-List-Map/","excerpt":"","text":"List to Map 一般可以分为以下几种情况:分组去重User.java1234567891011121314151617181920212223242526272829303132333435363738394041import lombok.AllArgsConstructor;import lombok.Data;import java.util.ArrayList;import java.util.List;import java.util.Map;import java.util.function.Function;import java.util.stream.Collectors;@Data@AllArgsConstructorpublic class User &#123; private String name; private Integer age; private Integer grade; private String sex; public static void main(String[] args) &#123; List&lt;User&gt; users =new ArrayList&lt;&gt;(); users.add(new User(&quot;zhangsan&quot;,18,90,&quot;男&quot;)); users.add(new User(&quot;zhangsan&quot;,19,90,&quot;男&quot;)); users.add(new User(&quot;lisi&quot;,19,91,&quot;女&quot;)); //list to map //1.分组，按照姓名分组 Map&lt;String, List&lt;User&gt;&gt; listMap = users.stream().collect( Collectors.groupingBy(User::getName)); //2.分组统计 男女 Map&lt;String, Long&gt; collect = users.stream().collect( Collectors.groupingBy(User::getSex, Collectors.counting()) ); //3.去重，根据年纪，后面的替换前面的，不加会跑出异常 Map&lt;Integer, User&gt; userMap = users.stream().collect( Collectors.toMap( User::getAge, Function.identity(), (oldUser, newUser) -&gt; newUser)); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zjcool.github.io/categories/Java/"}],"tags":[{"name":"Lamada","slug":"Lamada","permalink":"https://zjcool.github.io/tags/Lamada/"}],"author":"zhangj"}]}